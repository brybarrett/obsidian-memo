{
  "edges": [
    {
      "fromNode": "3d8750d68e3faf75",
      "fromSide": "top",
      "id": "65aaa79aba94e28c",
      "styleAttributes": {
      },
      "toNode": "3d5bca13a034e633",
      "toSide": "bottom"
    },
    {
      "fromNode": "b523b5d11fdf9bb2",
      "fromSide": "top",
      "id": "de0adf59e02a6f2b",
      "styleAttributes": {
      },
      "toNode": "8c3f493a3f0d9174",
      "toSide": "bottom"
    },
    {
      "fromNode": "a3c55c03a3a51682",
      "fromSide": "top",
      "id": "5b583152aa312de1",
      "styleAttributes": {
      },
      "toNode": "70410bcec6f02ab3",
      "toSide": "bottom"
    }
  ],
  "nodes": [
    {
      "height": 7514,
      "id": "bb749122958f23d9",
      "label": "For the interview",
      "styleAttributes": {
      },
      "type": "group",
      "width": 7230,
      "x": -4170,
      "y": 12512
    },
    {
      "height": 2421,
      "id": "167b61c400975127",
      "label": "Web part",
      "styleAttributes": {
      },
      "type": "group",
      "width": 5568,
      "x": -2925,
      "y": 17548
    },
    {
      "height": 2665,
      "id": "837409399d430f6a",
      "label": "Some DB stuff",
      "styleAttributes": {
      },
      "type": "group",
      "width": 2458,
      "x": -1738,
      "y": 14787
    },
    {
      "height": 3224,
      "id": "f210a9c33feb13a6",
      "label": "Functions",
      "styleAttributes": {
      },
      "type": "group",
      "width": 1663,
      "x": -555,
      "y": 4414
    },
    {
      "height": 2201,
      "id": "e6d535edbe7aad38",
      "label": "Collections",
      "styleAttributes": {
      },
      "type": "group",
      "width": 1808,
      "x": -2479,
      "y": 4414
    },
    {
      "height": 2524,
      "id": "562f6f4f42426501",
      "label": "Loop patterns, expressions",
      "styleAttributes": {
      },
      "type": "group",
      "width": 811,
      "x": -3433,
      "y": 4414
    },
    {
      "height": 300,
      "id": "30838c07f4e2f426",
      "label": "Untitled group",
      "styleAttributes": {
      },
      "type": "group",
      "width": 300,
      "x": 3390,
      "y": 12512
    },
    {
      "height": 3630,
      "id": "6f79be21e81a64f2",
      "label": "Variables and data types",
      "styleAttributes": {
      },
      "type": "group",
      "width": 3037,
      "x": -6568,
      "y": 4410
    },
    {
      "height": 1708,
      "id": "48569ba832fbe613",
      "label": "asyncio",
      "styleAttributes": {
      },
      "type": "group",
      "width": 2430,
      "x": 4620,
      "y": 9220
    },
    {
      "height": 2487,
      "id": "b632cca81efd9c83",
      "label": "Git",
      "styleAttributes": {
      },
      "type": "group",
      "width": 995,
      "x": -4110,
      "y": 17007
    },
    {
      "height": 1595,
      "id": "983c949e358f13c8",
      "styleAttributes": {
      },
      "text": "# Python `typing` Module - Quick Reference\n\n## Basic Generic Types\n\n- **`List[T]`** - List with elements of type T\n- **`Dict[K, V]`** - Dictionary with keys of type K and values of type V\n- **`Tuple[T, ...]`** - Tuple with elements of type T (variable length)\n- **`Tuple[T1, T2, T3]`** - Fixed-length tuple with specific types\n- **`Set[T]`** - Set with elements of type T\n- **`FrozenSet[T]`** - Immutable set with elements of type T\n\n## Optional and Union Types\n\n- **`Optional[T]`** - Either type T or None (shorthand for `Union[T, None]`)\n- **`Union[T1, T2, ...]`** - Can be any of the specified types\n- **`Any`** - Accepts any type (use sparingly)\n\n## Function Types\n\n- **`Callable[[arg_types], return_type]`** - Function signature type\n- **`Callable[..., return_type]`** - Function with any arguments\n\n## Advanced Types\n\n- **`TypeVar`** - Generic type variable for creating reusable generic functions/classes\n- **`Generic[T]`** - Base class for creating generic classes\n- **`Protocol`** - Structural typing (duck typing with type hints)\n- **`Final`** - Marks a variable as constant/unchangeable\n- **`Literal['value']`** - Restricts to specific literal values\n- **`ClassVar[T]`** - Class variable (shared across instances)\n\n## Metadata and Annotations\n\n- **`Annotated[T, metadata]`** - Adds extra metadata to a type without changing the type itself\n    \n    python\n    \n    ```python\n    from typing import Annotated\n    \n    # Add validation constraints\n    UserId = Annotated[int, \"Must be positive\"]\n    Name = Annotated[str, \"Max length: 50 chars\"]\n    \n    # Used with libraries like Pydantic for validation\n    Age = Annotated[int, Field(gt=0, lt=150)]\n    ```\n\n## Utility Types\n\n- **`NoReturn`** - Function never returns (always raises exception)\n- **`Type[T]`** - The class T itself (not instance of T)\n- **`NewType`** - Creates distinct types from existing ones\n- **`TypedDict`** - Dictionary with specific key-value type structure\n\n## Modern Alternatives (Python 3.9+)\n\n- `list[T]` instead of `List[T]`\n- `dict[K, V]` instead of `Dict[K, V]`\n- `tuple[T, ...]` instead of `Tuple[T, ...]`\n- `T | U` instead of `Union[T, U]` (Python 3.10+)",
      "type": "text",
      "width": 1095,
      "x": -4650,
      "y": 4431
    },
    {
      "height": 1004,
      "id": "ede43c642dc15653",
      "styleAttributes": {
      },
      "text": "\n## Memory Management and Object References\n\nThink of Python variables as name tags attached to objects in memory, rather than boxes containing values. This mental model helps explain many behaviors that might seem strange otherwise.\n\npython\n\n```python\n# Creating objects and references\nfirst_list = [1, 2, 3]      # Creates a list object, first_list points to it\nsecond_list = first_list    # second_list points to the SAME object\nthird_list = [1, 2, 3]      # Creates a NEW list object with same contents\n\nprint(f\"first_list ID: {id(first_list)}\")\nprint(f\"second_list ID: {id(second_list)}\")   # Same as first_list\nprint(f\"third_list ID: {id(third_list)}\")     # Different from others\n\n# Modifying through any reference affects all references to the same object\nsecond_list.append(4)\nprint(f\"first_list after second_list change: {first_list}\")   # [1, 2, 3, 4]\nprint(f\"third_list remains: {third_list}\")                    # [1, 2, 3]\n```\n\n### Understanding Reference Counting\n\nPython uses reference counting for memory management. When no variables reference an object anymore, Python can garbage collect it:\n\npython\n\n```python\nimport sys\n\n# Create a list and check its reference count\nmy_list = [1, 2, 3]\nprint(f\"Reference count: {sys.getrefcount(my_list) - 1}\")  # -1 to exclude getrefcount's own reference\n\n# Create another reference\nanother_ref = my_list\nprint(f\"Reference count after second reference: {sys.getrefcount(my_list) - 1}\")\n\n# Remove one reference\ndel another_ref\nprint(f\"Reference count after deletion: {sys.getrefcount(my_list) - 1}\")\n\n# When my_list goes out of scope or is deleted, the object can be garbage collected\n```",
      "type": "text",
      "width": 1095,
      "x": -4650,
      "y": 6058
    },
    {
      "height": 1217,
      "id": "be683cd09338289b",
      "styleAttributes": {
      },
      "text": "### Mutability vs Immutability\n\nMutable objects can be modified after creation while maintaining their identity:\n- Lists,\n- Dicts,\n- Sets\n\nImmutable objects cannot be modified after creation. Any operation that appears to change them actually creates a new object\n- Strings\n- Tuples\n- Numbers\n\n\n```python\ndef add_item_to_list(item, target_list): \n\t\"\"\"This function modifies the original list!\"\"\" \n\ttarget_list.append(item)\n\treturn target_list \n\ndef add_word_to_string(word, target_string): \n\t\"\"\"This function creates a new string, leaving original unchanged\"\"\" \n\ttarget_string += f\" {word}\"\n\treturn target_string\n```\n\n```python\ndef create_student_record(name, grades=[]):  # DANGEROUS!\n    \"\"\"This is a common Python gotcha\"\"\"\n    grades.append(85)  # Modifying the default list\n    return {\"name\": name, \"grades\": grades}\n\n# First call\nstudent1 = create_student_record(\"Alice\")\nprint(f\"Student 1: {student1}\")\n\n# Second call - surprise! The default list still has previous data\nstudent2 = create_student_record(\"Bob\")\nprint(f\"Student 2: {student2}\")  # Bob inherits Alice's grade!\n\nprint(f\"Same grades list? {student1['grades'] is student2['grades']}\")  # True\n\n# The correct way to handle this:\ndef create_student_record_correct(name, grades=None):\n    \"\"\"Safe version using None as default\"\"\"\n    if grades is None:\n        grades = []  # Create a new list each time\n    grades.append(85)\n    return {\"name\": name, \"grades\": grades}\n```\n```",
      "type": "text",
      "width": 838,
      "x": -5548,
      "y": 4431
    },
    {
      "height": 1015,
      "id": "8c3775a99d6f3232",
      "styleAttributes": {
      },
      "text": "## Identity vs Equality: `is` vs `==`\n\nThis distinction becomes crucial when working with mutable objects:\n\npython\n\n```python\n# Creating different scenarios\nlist_a = [1, 2, 3]\nlist_b = [1, 2, 3]  # Same contents, different object\nlist_c = list_a     # Same object\n\nprint(\"=== Identity Tests (is) ===\")\nprint(f\"list_a is list_b: {list_a is list_b}\")  # False - different objects\nprint(f\"list_a is list_c: {list_a is list_c}\")  # True - same object\n\nprint(\"\\n=== Equality Tests (==) ===\")\nprint(f\"list_a == list_b: {list_a == list_b}\")  # True - same contents\nprint(f\"list_a == list_c: {list_a == list_c}\")  # True - same contents AND same object\n\nprint(\"\\n=== Memory Addresses ===\")\nprint(f\"list_a ID: {id(list_a)}\")\nprint(f\"list_b ID: {id(list_b)}\")  # Different\nprint(f\"list_c ID: {id(list_c)}\")  # Same as list_a\n```\n\n### Special Case: Small Integer Caching\n\nPython has some optimizations that can be surprising:\n\npython\n\n```python\n# Small integers are cached\na = 100\nb = 100\nprint(f\"a is b (small int): {a is b}\")  # True - same object!\n\n# Large integers are not cached\nx = 1000\ny = 1000\nprint(f\"x is y (large int): {x is y}\")  # False - different objects!\n\n# This is why you should use == for value comparison, not is\nprint(f\"x == y: {x == y}\")  # True - same value\n```",
      "type": "text",
      "width": 831,
      "x": -5541,
      "y": 5720
    },
    {
      "color": "4",
      "height": 1315,
      "id": "7adfe5d5af699c74",
      "styleAttributes": {
      },
      "text": "### Copy vs. deepcopy\n\n### ✅ `copy.copy()` – **Shallow Copy**\n\n- **Creates a new object**, but **does not create copies of nested objects** (like lists inside lists).\n    \n- The outer object is copied, but inner objects are **still referenced**.\n    \n\n#### Example:\n\npython\n\nКопироватьРедактировать\n\n```python\nimport copy \noriginal = [1, [2, 3]] \nshallow = copy.copy(original)  \nshallow[1][0] = 99 \nprint(original)  # Output: [1, [99, 3]] – changed!\n```\n\n> Notice how changing the nested list in `shallow` also affects `original`.\n\n---\n\n### ✅ `copy.deepcopy()` – **Deep Copy**\n\n- **Recursively copies** everything — including all nested structures.\n\n- The result is **fully independent** of the original object.\n    \n\n#### Example:\n\n\n```python\nimport copy\noriginal = [1, [2, 3]]\ndeep = copy.deepcopy(original)  \ndeep[1][0] = 99 \nprint(original)  # Output: [1, [2, 3]] – unchanged`\n```",
      "type": "text",
      "width": 833,
      "x": -6449,
      "y": 4887
    },
    {
      "height": 1197,
      "id": "e62fc5ade8e0d5ec",
      "styleAttributes": {
      },
      "text": "### More about memory management\n\nNamespaces:\n- Local - локальное пространство имён текущей функции\n- Enclosing - пространства имён внешних функций\n- Global - пространство имён модуля\n- Built-in - встроенные имена\n\n```python\nx = \"global\"\ndef outer():\n    x = \"enclosing\"\n    def inner():\n        x = \"local\"\n        print(x)  # выведет \"local\"\n    inner()\n    print(x)  # выведет \"enclosing\"\nouter()\nprint(x)  # выведет \"global\"\n\n```\n\n![[Pasted image 20250602140127.png]]",
      "type": "text",
      "width": 1095,
      "x": -6508,
      "y": 6773
    },
    {
      "height": 1089,
      "id": "b523b5d11fdf9bb2",
      "styleAttributes": {
      },
      "text": "`git init` - создание репо (.git, tracks the diff (changes to the codebase))\nTake snapshots or commits (current states) of the codebase\nEvery commit has a unique id, linked to its parent\n\n`git add .`  (to track)\n`git commit -m \"initial commit\"`\n\n`git status` - посмотреть изменения\nMultiple teams -> branching\n`git branch new_branch`\n`git checkout new_branch`\n\nMerging\n\n`git merge `\n\n\nВ команде:\n`git clone`\n`git branch; git checkout`\n\nPull request - функционал, который позволяет предложить внести изменения в основную ветку:\n`git push`- чтобы ветка оказалась на удалённом репозитории\n`git pull` - чтобы стянуть из репо изменения, сделанные в ветке\n`git revert` - откат изменений\n\n**Git Flow**\n\nMaster ветка - содержит стабильный код (продовый)\nDevelop ветка - происходит основная разработка\nВспомогательные - feature ветки, которые создаются для новых функций. Ответвляются от develop и вливаются после pull реквеста и merge\nRelease ветки создаются для подготовки к релизу. На них тестирование, исправление ошибок\nHotfix ветки для исправлении критических ошибок",
      "type": "text",
      "width": 942,
      "x": -4095,
      "y": 18385
    },
    {
      "height": 910,
      "id": "a8ba8ea2986e2653",
      "styleAttributes": {
      },
      "text": "### Потоки, процессы и корутины\n- **Процесс** - независимая единица выполнения программы, имеющая своё адресное пространство и ресурсы\n- **Поток** - лёгкая единица выполнения внутри процесса, которая использует ресурсы процесса, но может работать независимо друг от друга\nПреимущества: поддерживают параллельное выполнение, если доступны ресурсы, используются в системах с многоядерными процессорами для повышения производительности\nНедостатки: создание потоков и переключение между ними - ресурсоёмкие операции. Общение между потоками требует сложной синхронизации\n- **Корутины** - функции, которые могут приостанавливать и возобновлять выполнение. \nПреимущества: лёгковесность, асинхронная обработка без блокировки потоака, простота.\nНедостатки: не обеспечивают истинный паараллелизм, не всегда подходят для задач, требующих больших вычислений, которые могут блокировать поток.\n\n\n||**Потоки (`threading`)**|**Корутины (`asyncio`)**|\n|---|---|---|\n|Уровень|ОС|Язык (Python)|\n|Параллелизм|Возможен|Нет, только конкурентность|\n|Переключение|ОС (дорого)|Python-интерпретатор (дешево)|\n|Сложность|Потенциально высокая (race conditions, lock)|Управляемая, последовательная логика|\n|Использование CPU|Да (но с GIL — спорно)|Нет, ориентированы на I/O|\n|Пример задач|Расчёты, обработка фото|Запросы к БД, HTTP-запросы|\n|Отладка|Сложно (многопоточность)|Легче (асинхронность)|\n\n|Сценарий|Рекомендуемый подход|\n|---|---|\n|Много сетевых запросов|`asyncio`, корутины|\n|Работа с файловой системой|`asyncio`, если есть поддержка (например, `aiofiles`)|\n|Обработка CPU-интенсивных задач|Потоки или процессы (`multiprocessing`)|\n|Требуется реальный параллелизм|Потоки (в других языках) или процессы в Python|",
      "type": "text",
      "width": 965,
      "x": -4148,
      "y": 15593
    },
    {
      "file": "Pictures/Pasted image 20250610101027.png",
      "height": 255,
      "id": "ff5a896f5eec46c2",
      "styleAttributes": {
      },
      "type": "file",
      "width": 400,
      "x": -4065,
      "y": 16586
    },
    {
      "color": "6",
      "height": 945,
      "id": "8df78ca81f46cf32",
      "styleAttributes": {
      },
      "text": "### Классы 3\n\n**Abstract classes**\n```python\nfrom abc import ABC, abstractmethod\n\nclass Abs(ABC):\n    @abstractmethod\n    def method(self):\n        pass\n\nclass Child(Abs):\n    def method(self):\n        print(\"implemented\")\n```\n\n\n**Dataclasses**\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass DCA:\n    c: str\n    a: int = 1\n    b: int = 2\n\n@dataclass\nclass DC(DCA):\n    #def __init__(self):\n    #    super().__init__()\n    b: str = 'b'\n    c: str = 'c'\n\n```",
      "type": "text",
      "width": 556,
      "x": -4014,
      "y": 8249
    },
    {
      "color": "6",
      "height": 945,
      "id": "ece37644923674a6",
      "styleAttributes": {
      },
      "text": "### Классы 2\n\n**Inheritance**\n```python\nclass A:\n    def __init__(self, aarg, arg=10):\n        self.aarg = 2\n        self.arg = arg\n        \nclass B:\n    def __init__(self, barg, arg=100):\n        self.barg = 2\n        self.arg = arg\n        \nclass C(A, B):\n    def __init__(self, aarg, barg, carg=3):\n        #super().__init__() инициализируется от A\n        B.__init__(self, barg)\n        A.__init__(self, aarg)\n        self.carg=3\n\nc = C(aarg=1, barg=2)\nprint(C.__mro__)\nprint(c.arg, c.aarg, c.barg, c.carg)\n\n```\n\\* super() возвращает прокси-объект, который позволяет вызвать методы следующего порядка в цепочке MRO\n`super().__init__()` \n\nАльтернатива примеру:\n\n```python\nclass A:\n\tdef __init__(self, aarg, **kwargs):\n\t\tsuper().__init__(**kwargs)\nclass B:\n\t... # аналогично\nclass C(A, B):\n\tdef __init__(self, aarg, barg, carg):\n\t\tsuper().__init__(aarg=aarg, barg=barg)\n```",
      "type": "text",
      "width": 556,
      "x": -4599,
      "y": 8249
    },
    {
      "file": "Pictures/Pasted image 20250610120613.png",
      "height": 240,
      "id": "cc8a512a35fd008a",
      "styleAttributes": {
      },
      "type": "file",
      "width": 400,
      "x": -3592,
      "y": 19203
    },
    {
      "height": 1337,
      "id": "8c3f493a3f0d9174",
      "styleAttributes": {
      },
      "text": "### Git\n\n| Команда                     | Назначение                                               |\n| --------------------------- | -------------------------------------------------------- |\n| `git init`                  | Инициализация репозитория                                |\n| `git clone <url>`           | Клонирование репозитория                                 |\n| `git status`                | Проверка состояния репозитория                           |\n| `git add <file>` / `.`      | Добавление файлов в индекс                               |\n| `git commit -m \"msg\"`       | Создание коммита                                         |\n| `git push` / `git pull`     | Отправка/получение изменений в/из удалённого репозитория |\n| `git log`                   | История коммитов                                         |\n| `git diff`                  | Просмотр отличий                                         |\n| `git reset`                 | Откат индекса/коммитов                                   |\n| `git branch` / `git switch` | Управление ветками                                       |\n| `git merge <branch>`        | Слияние веток                                            |\n| `git rebase`                | Перенос коммитов поверх другой ветки                     |\n|                             |                                                          |\n1. `git fetch` связывается с удаленным репозиторием и загружает все изменения (коммиты, ветки, теги) в локальный репозиторий, не меняя текущую рабочую директорию.\n2. `git merge` - это команда Git, которая используется для слияния веток в Git репозитории. Она объединяет изменения из одной ветки в другую, создавая новый коммит, который объединяет историю обеих веток\n3. `git pull` в Git - это команда, которая сочетает в себе две операции: `git fetch` (загружает новые изменения из удаленного репозитория в локальный) и `git merge` (автоматически объединяет эти изменения с текущей локальной веткой)\n4. `git checkout` в Git - это универсальная команда, используемая для переключения между ветками, коммитами и даже файлами, а также для восстановления файлов в рабочем каталоге до состояния, указанного в ветке, коммите или индексе\n5. `Git rebase` и `git merge` – это два способа объединения изменений между ветками Git. Разница в том, как они делают это: \n\n\t- `git merge`:\n\t    \n\t    Объединяет ветки, создавая новый коммит, который фиксирует момент слияния и сохраняет историю ветвления.\n\t    \n\t- `git rebase`:\n\t    \n\t    Применяет изменения из одной ветки поверх другой, переписывая историю, чтобы она выглядела так, будто все изменения сделаны последовательно в одной ветке.\n\n```\n# Список веток\ngit branch\n\n# Создание ветки \"new-feature\"\ngit branch new-feature\n\n# Переименование ветки \"old-name\" в \"new-name\"\ngit branch --rename old-name new-name\n\n# Удаление ветки \"old-branch\" (если она слияна)\ngit branch -d old-branch\n\n# Удаление ветки \"old-branch\" (если она не слияна)\ngit branch -D old-branch\n```\n",
      "type": "text",
      "width": 942,
      "x": -4095,
      "y": 17027
    },
    {
      "height": 2122,
      "id": "fd8ebe9e14b7eab2",
      "styleAttributes": {
      },
      "text": "# FastAPI Interview & Education Q&A Guide\n## Basics and Fundamentals\n\n### What is FastAPI?\n\nFastAPI is a modern, fast web framework for building APIs with Python 3.7+ based on standard Python type hints. It's built on top of Starlette for web parts and Pydantic for data parts, offering automatic API documentation, high performance, and easy development.\n\n### What are the key features of FastAPI?\n\n- **Fast performance**: One of the fastest Python frameworks, comparable to NodeJS and Go\n- **Fast development**: Increases development speed by 200-300%\n- **Automatic documentation**: Interactive API docs with Swagger UI and ReDoc\n- **Type safety**: Based on Python type hints with runtime validation\n- **Modern Python**: Uses Python 3.7+ features like async/await\n- **Standards-based**: Based on OpenAPI and JSON Schema\n- **Editor support**: Great autocomplete and error detection\n\n### How does FastAPI compare to Flask and Django?\n\n- **Performance**: FastAPI is significantly faster than both Flask and Django\n- **Type safety**: FastAPI has built-in type validation, while Flask/Django require additional libraries\n- **Documentation**: FastAPI automatically generates interactive docs, others require manual setup\n- **Async support**: FastAPI has native async support, Flask has limited support, Django added it recently\n- **Learning curve**: FastAPI is easier for API development, Django is more comprehensive for full web apps\n\n## Installation and Setup\n### How do you install FastAPI?\n\n```bash\npip install fastapi\npip install \"uvicorn[standard]\"  # ASGI server for running the app\n```\n### How do you create a basic FastAPI application?\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello World\"}\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n### How do you run a FastAPI application?\n```bash\nuvicorn main:app --reload\n# main: the file main.py\n# app: the FastAPI instance\n# --reload: restart server on code changes (development only)\n```\n\n## Path Operations and Routing\n\n### What are path operations in FastAPI?\n\nPath operations are the combination of an HTTP method (GET, POST, PUT, DELETE, etc.) and a path. They define the endpoints of your API and what happens when a client makes a request to each endpoint.\n\n### How do you define path parameters?\n\npython\n\n```python\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    return {\"user_id\": user_id}\n\n# With validation\nfrom fastapi import Path\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int = Path(..., gt=0, description=\"The ID of the user\")):\n    return {\"user_id\": user_id}\n```",
      "type": "text",
      "width": 1745,
      "x": 7309,
      "y": 11217
    },
    {
      "height": 1951,
      "id": "b573ad4368f77724",
      "styleAttributes": {
      },
      "text": "## CPython\n\n### Foundational understanding\n#### Q: What actually is CPython and how does it differ from Python?\nCPython - reference implementation of the Python, written in C.\nPython - language specification (rules and syntax), while CPython is the software that actually reads and executes Python code\nOther implementations: Pypy, Jython, IronPython\n\n#### Q: CPython execution model\n1\\. CPython takes source code and parses int into an Abstract Syntax Tree. \n2\\. Then, the AST gets compiled into bytecode (lower-level, platform independent instruction set)\n3\\. Bytecode is an intermediate language that runs on the Python Virtual Machine (PVM)\nPVM reads bytecode instructions one by one and executes them\n- This design give Python flexibility (the PVM can modify behavior in runtime), but also explains why Python is generally slower than compiled languages\n\n### Memory Management\n#### Q: CPython memory management\nPrimary mechanism is reference counting. E.g. `x = [1, 2, 3]`, y = x => reference count to 2. \nOut of scope/reassigning => rc decreases. 0 => garbage collector. GC algorithm for circular references\n\\+ Memory pools and arenas to optimize allocation of small objects\n#### Q: What happens when CPython runs out of memory?\nGC becomes more aggressive, not enought => `MemoryError` exception (maintains a small reserve of memory for handling errors)\n\n### GIL (Global Interpreter Lock)\n#### Q: What is GIL and why does it exists?\nThe  Global Interpreter Lock is perhaps CPython's most controversial feature\n**GIL** - **mutex** (mutual exclusion lock) that protects access to Python objects, preventing multiple threads from executing Python bytecode simultaneously.  Even on a multi-core machine, only one thread can run Python code at a time. \nReference counting isn't thread-safe by default. Without the GIL, multiple threads could simultaneously modify an object's reference count, leading to memory corruption, crashes, or objects being freed while still in use. GIL - simple reliable solution. Without it, every single operation on Python object would need individual lock\n#### Q: How does the GIL affect multi-threaded Python programs?\nI/O bound operations - minimal impact (CPython releases the GIL during these operations)\nFor CPU-intensive tasks, the GIL becomes a significant bottleneck. Threads will run one at a time, providing no performance benefit over single-threaded code. Even slightly worse performance (overhead of context switching between threads). Multiprocessing: every process has its own \n\n### Bytecode and performance\n#### Q: What is Python bytecode and how can you inspect it?\nPython bytecode is the intermediate representation that CPython creates from the source code. Series of instructions that the Python Virtual machine can execute efficiently. `dis.dis(function_name)`\nCPython caches the compiled bytecode\n\n#### Q: How does CPython optimize code execution?\n- At a compile time, CPython performs constant folding (calculating constant expressions at compile time) and some dead code elimination\n- Interpretator caches method lookups to avoid repeatedly searching through the inheritance history\n- Prioritizes simplicity and maintainability over peak performance\n\n### Integration and Extensions\n#### Q: How does CPython integrate with C code?\nC API allows to write extensions in C that look and behave like regular Python modules\nNumpy, pandas, ....",
      "type": "text",
      "width": 940,
      "x": -4148,
      "y": 13609
    },
    {
      "height": 514,
      "id": "4d1a708fc02be5e2",
      "styleAttributes": {
      },
      "text": "### К собеседованию (от ChatGPT)\n### ✅ Типы данных и структуры:\n\n- `int`, `float`, `str`, `bool`, `None`\n    \n- `list`, `tuple`, `set`, `dict` — сравнение, особенности, сложности операций\n    \n- `collections` (`deque`, `Counter`, `defaultdict`, `OrderedDict`, `ChainMap`)\n    \n- `frozenset`, `namedtuple`, `dataclass`\n\n### ✅ Управляющие конструкции:\n\n- `if`,  `else`, `elif`, `for`, `while`, `break`, `continue`, `pass`\n    \n- генераторы списков и словарей: `[x for x in iterable if condition]`, `{x: f(x) for x in iterable if condition}`\n    \n- генераторы (`yield`, `yield from`)\n    \n\n**Важно:**\n\n- умение писать выражения в одну строку — генераторы, `any`, `all`, `zip`, `enumerate`",
      "type": "text",
      "width": 1210,
      "x": -4148,
      "y": 12522
    },
    {
      "height": 513,
      "id": "d42388decdf7a737",
      "styleAttributes": {
      },
      "text": "### Изменяемые vs неизменяемые тд\n- Изменяемый (mutable) объект - тот, что можно изменить \"на месте\" без смены ссылки\n- Неизменяемый (immutable) объект - нельзя изменить \"на месте\", любые измения создают новый объект\n\n🔧 Примеры:\n\n| Тип            | Изменяемость   | Примеры              |\n| -------------- | -------------- | -------------------- |\n| `int`, `float` | ❌ неизменяемый | `1`, `3.14`          |\n| `str`, `tuple` | ❌ неизменяемый | `\"hello\"`, `(1, 2)`  |\n| `list`, `dict` | ✅ изменяемый   | `[1, 2]`, `{'a': 1}` |\nНеизменяемость - необходимое условие хэшируемости.\nЧтобы объект мог быть ключом словаря:\n1. Должен быть неизменяемым (или хотя бы вести себя как такой)\n2. Должен иметь реализованные `__hash__()` и `__eq__()` \n3. Хэш должен оставаться стаблиьным на протяжении всей жизни объекта",
      "type": "text",
      "width": 1210,
      "x": -4148,
      "y": 13062
    },
    {
      "height": 2851,
      "id": "6c9cfb82ed4b4113",
      "styleAttributes": {
      },
      "text": "### Database Integration\n\nAn ORM (Object-Relational Mapping) lets you work with database tables as if they were Python classes. Instead of writing SQL queries, you work with Python objects.\n\n```python\n# database.py\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom datetime import datetime\n\n# Database connection\n# For SQLite (simple, file-based database)\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n# For PostgreSQL (production database)\n# SQLALCHEMY_DATABASE_URL = \"postgresql://user:password@localhost/dbname\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL,\n    connect_args={\"check_same_thread\": False}  # Only needed for SQLite\n)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Database model (represents a table)\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n    email = Column(String, unique=True, index=True)\n    age = Column(Integer)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n# Create the database tables\nBase.metadata.create_all(bind=engine)\n\n# Dependency to get database session\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n\n**Understanding This Setup:**\n\n1. **Engine**: The connection to your database\n2. **SessionLocal**: A factory for creating database sessions (think of sessions as conversations with the database)\n3. **Base**: The base class that all your database models inherit from\n4. **User Model**: Defines the structure of your users table\n5. **get_db()**: A dependency that provides a database session to your API endpoints\n\n#### Integrating Database with FastAPI\n\n```python\n# main.py\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom typing import List\nimport database\nfrom pydantic import BaseModel, EmailStr\n\napp = FastAPI()\n\n# Pydantic models for API\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    email: str\n    age: int\n    is_active: bool\n    \n    class Config:\n        orm_mode = True  # Allows Pydantic to work with SQLAlchemy models\n\n# CRUD operations\n@app.post(\"/users/\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\ndef create_user(user: UserCreate, db: Session = Depends(database.get_db)):\n    # Check if user already exists\n    db_user = db.query(database.User).filter(database.User.email == user.email).first()\n    if db_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    db_user = database.User(**user.dict())\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)  # Get the ID that was auto-generated\n    return db_user\n\n@app.get(\"/users/\", response_model=List[UserResponse])\ndef get_users(skip: int = 0, limit: int = 100, db: Session = Depends(database.get_db)):\n    users = db.query(database.User).offset(skip).limit(limit).all()\n    return users\n\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\ndef get_user(user_id: int, db: Session = Depends(database.get_db)):\n    user = db.query(database.User).filter(database.User.id == user_id).first()\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"User not found\"\n        )\n    return user\n```\n\n**Understanding Dependencies:**\n\nThe `Depends(database.get_db)` syntax is FastAPI's dependency injection system. It automatically:\n\n1. Calls the `get_db()` function\n2. Passes the result to your endpoint function\n3. Handles cleanup (closing the database session) automatically\n\nThis pattern ensures proper resource management and makes your code more testable.",
      "type": "text",
      "width": 863,
      "x": 6063,
      "y": 11217
    },
    {
      "height": 1445,
      "id": "435a6fb57c7942cc",
      "styleAttributes": {
      },
      "text": "### Request and Response Handling\nWhen clients send data to your API (like creating a new user), that data comes in the request body. FastAPI automatically parses JSON request bodies:\n\npython\n\n```python\nfrom fastapi import FastAPI\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.post(\"/users/\")\ndef create_user(user_data: dict):\n    # FastAPI automatically converts JSON to a Python dictionary\n    return {\"received\": user_data}\n\n# But we can be more specific about what we expect:\n@app.post(\"/items/\")\ndef create_item(name: str, price: float, description: Optional[str] = None):\n    return {\n        \"name\": name,\n        \"price\": price,\n        \"description\": description\n    }\n```\n\n### Response Models and Status Codes\n\nHTTP status codes communicate the outcome of requests. Here's how to use them effectively:\n\npython\n\n```python\nfrom fastapi import FastAPI, HTTPException, status\nfrom typing import Dict\n\napp = FastAPI()\nfake_db: Dict[int, dict] = {}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    if user_id not in fake_db:\n        # Raise an HTTP exception with appropriate status code\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"User not found\"\n        )\n    return fake_db[user_id]\n\n@app.post(\"/users/\", status_code=status.HTTP_201_CREATED)\ndef create_user(user_data: dict):\n    user_id = len(fake_db) + 1\n    fake_db[user_id] = user_data\n    return {\"user_id\": user_id, **user_data}\n```",
      "type": "text",
      "width": 622,
      "x": 5398,
      "y": 11217
    },
    {
      "height": 974,
      "id": "93a7b1ad9c213fd2",
      "styleAttributes": {
      },
      "text": "### FastAPI Fundamentals\n\n```python\n# main.py\nfrom fastapi import FastAPI\n\n# Create an instance of the FastAPI class\n# This instance will be your entire application\napp = FastAPI()\n\n# Define a route using a decorator\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n```\n\n**Breaking Down the Components:**\n\n1. **The FastAPI Instance**: `app = FastAPI()` creates your application object. This is like the foundation of a building - everything else attaches to it.\n2. **Route Decorators**: `@app.get(\"/\")` tells FastAPI \"when someone makes a GET request to the root path (/), run the function below.\" The decorator pattern is Python's way of modifying function behavior without changing the function itself.\n3. **Path Operation Functions**: `def read_root():` is the actual code that runs when someone hits your endpoint. FastAPI automatically converts the returned dictionary to JSON.\n\n```bash\nuvicorn main:app --reload\n```\n**Understanding This Command:**\n\n- `uvicorn`: The ASGI server we're using\n- `main:app`: Look in the file `main.py` for an object called `app`\n- `--reload`: Automatically restart the server when you change your code (development only)\n\nVisit `http://127.0.0.1:8000` in your browser, and you'll see your API response.\nMore importantly, visit `http://127.0.0.1:8000/docs` to see FastAPI's automatic interactive documentation - this is one of FastAPI's killer features.",
      "type": "text",
      "width": 718,
      "x": 4647,
      "y": 11982
    },
    {
      "height": 1116,
      "id": "edd294822799214a",
      "styleAttributes": {
      },
      "text": "### QA по asyncio\n\nQ: asyncio - ?\nA: Стандартная библиотека для написания асинхронного кода с использованием async/await синтаксиса. Средства запуска event loops, запуска корутин, управления задачами и взаимодействия с IO\n\nQ: многопоточность vs asyncio\nA: многопоточность - несколько потоков (полезно при блокирующих задачах) (???)\nasyncio работает в одном потоке, но позволяет выполнять множество операций, ожидающих завершения (???), без блокировки. IO-bounded задачи\n\nQ: запуск корутины\nA: `asyncio.run(coroutine())`, автоматическое управление event loop\n\nQ: await\nA: await приостанавливает выполнение текущей корутины до завершения ожидаемой корутины или awaitable-объекта. Только внутри `async def` функций\n\nQ: asyncio.Task\nA: Task - обёртка над корутиной, которая позволяет ей выполняться параллельно с другими задачами в рамках одного event loop\n\nQ: параллельное выполнение корутин\nA: `asyncio.gather()` или `asyncio.create_task()`\n```python\nawait asyncio.gather(task1(), task2())\n# или\nt1 = asyncio.create_task(task1())\nt2 = asyncio.create_task(task2())\nawait t1\nawait t2\n\n```\nQ: Event loop\nA: Сердце asyncio. Запускает корутины, отслеживает события и переключается между задачами, когда они приостанавливаются. В `asyncio.run()` event loop создаётся и запускается автоматически.\n\nQ: асинхронные менеджеры и генераторы\n\nQ: контекстные менеджеры\n\nQ: исключения",
      "type": "text",
      "width": 772,
      "x": 6265,
      "y": 9238
    },
    {
      "height": 1737,
      "id": "6220e4cb30dc1041",
      "styleAttributes": {
      },
      "text": "### Iterables, iterators, generators\n**Iterable** - any object that can be iterated over 1 element at a time. An object is iterable if it implements the `__iter__()` method, which return an iterator object\n\nIterator protocol: when using for loop, Python internally:\n1) Calls `iter()` on the iterable to get an iterator\n2) Repeatedly calls `next()` on the iterator until it raises `StopIteration`\n\n```python\nclass CountUp:\n    def __init__(self, max_count):\n        self.max_count = max_count\n    \n    def __iter__(self):\n        self.current = 0\n        return self\n    \n    def __next__(self):\n        if self.current < self.max_count:\n            self.current += 1\n            return self.current\n        raise StopIteration\n\n# Usage\nfor num in CountUp(3):\n    print(num)  # Prints 1, 2, 3\n```\n\n**Iterable** - an object you can iterate over (has `__iter__()`), **iterator** - an object that produces values one at a time (both `__iter__` and `__next__`). \n**All iterators are iterables, but not vice versa**\n\n**Generators** - special type o iterable that produces values lazily (on-demand) rather than creating all walues at once in memory. \n\n```python\ndef count_up(init_val=0):\n    while True:\n        yield init_val\n        init_val += 1\n```\n\nAdvanced features:\n```python\ndef echo_generator():\n    while True:\n        received = yield\n        print(f\"Received: {received}\")\n\ngen = echo_generator()\nnext(gen)  # Prime the generator\ngen.send(\"Hello\")  # Prints \"Received: Hello\"\ngen.send(\"World\")  # Prints \"Received: World\"\n```\n\n```python\ndef robust_generator():\n    try:\n        while True:\n            yield \"Working...\"\n    except GeneratorExit:\n        print(\"Generator is closing\")\n    finally:\n        print(\"Cleanup complete\")\n```\n\n```python\ndef generator1():\n    yield 1\n    yield 2\n\ndef generator2():\n    yield 3\n    yield 4\n\ndef combined():\n    yield from generator1()\n    yield from generator2()\n```",
      "type": "text",
      "width": 897,
      "x": -6280,
      "y": 11538
    },
    {
      "height": 514,
      "id": "0d87be0e33a10092",
      "styleAttributes": {
      },
      "text": "### Последовательности (sequence)\n\n- **Основы**:\nЛёгкий доступ по индексу: `__getitem__()`, `__len__()`; `count()`, `index()`, `__contains__()`, `__reversed__()`\nОсновные типы: list, tuple, range, str, bytes\n- **Операции**: in, +, \\*, `[i]`, `[i:j:k]`, `len`, `min`, `max`, `index`, `count`\nДля изменяемых: `s[i] = x`, `s[i:j:k] = t`, `append`, `clear`, `copy`, `extend`, `insert`, `pop`, `remove`, `reverse`\n- **Строки** неизменяемы. В Python 3 - один вид строк `str`. `.join()`, `.split()`. `encode()`\n- **Список vs кортеж**. Списки - изменяемые последовательности, кортежи - неизменяемые последовательности. \n- **range** - итерируемый объект (iterable, c реализацией `__iter__`, которая возвращает итератор). `range(start, stop, step)`\nПоддерживаются слайсы\n- Уникальный список (алгозадача), OrderedDict\n- `a, b, c = (1, 2, 3)`\n- Сравнение последовательностей (лексикографическое, одинаковый тип)",
      "type": "text",
      "width": 937,
      "x": -7313,
      "y": 9238
    },
    {
      "height": 765,
      "id": "71e50211f8c9da76",
      "styleAttributes": {
      },
      "text": "### Множества и отображения\n\n- **Хешируемый ли объект**: `__hash__()`, `__eq__()`. Example: `hash(3)`, `int.__eq__(5, 6)`\n- **Множество** - неупорядоченная коллекция хешируемых объектов, которые не повторяются. Нет индексов. `set`, `frozenset`. Применение: быстрая проверка на вхождение элемента во множество, добавление, удаление, операции объединения, пересечения, etc. \n- **Операции**: `set([iterable])`, `len`, `in`, `isdisjoint`, `issubset`, `s < t`, `issuperset`, `union`, ...\nДля изменяемых: `s.update(t, ...)`, `intersection_update()`, ..., `add`, `remove`, `discard`, `pop`, `clear`\nПроверка на равенство поэлементно \n- **Отображение (Mapping)** - инстанс реализации абстрактного класса `collections.Mapping` (`get()`, `items()`, `keys()`, `values()`) или `collections.MutableMapping` (`clear()`, `get()`, `items()`, `keys()`, `pop()`, `popitem()`, `setdefault()`, `update()`, `values()`). \nОтносятся: `dict`, `collections.defaultdict`, `collections.OrderedDict`, `collections.Counter\n- **Использование чисел как ключей** `int(1)`, `float(1.0)`\n- **Операции**: \n`len`, `d[key]`, `key in d`, `iter(d)`, `clear()`, `copy()`, `get`, `items`, `keys`, `pop`, `popitem`, `setdefault`, `update`, `values`\n- **Метод items** возвращает объекты представленя словаря. iter, len, x in\n- **Сортировка списка по полю словаря**\n- **Ключом** может быть любой хэшируемый объект\n- `dict(zip(keys, values))`\n- **Устройство хэш-таблицы под капотом, коллизии**",
      "type": "text",
      "width": 937,
      "x": -7313,
      "y": 9790
    },
    {
      "height": 1737,
      "id": "165645abd58d7951",
      "styleAttributes": {
      },
      "text": "### Containers and mappings\n\n**Containers** - objects that hold other objects and allow to test membership\n\nContainer implements `__contain__`, which defines how the `in` works\n\n```python\nclass CustomContainer: \n\tdef __init__(self, items): \n\t\tself.items = items \n\tdef __contains__(self, item): \n\t\treturn item in self.items \n\tdef __iter__(self): \n\t\treturn iter(self.items)\n```\n\n```python\nclass NumberRange: \n\tdef __init__(self, start, end, step=1): \n\t\tself.start = start \n\t\tself.end = end \n\t\tself.step = step \n\tdef __contains__(self, item): \n\t\tif not isinstance(item, (int, float)): \n\t\t\treturn False \n\t\tif self.step > 0:\n\t\t\treturn (self.start <= item < self.end and (item - self.start) % self.step == 0) \n\t\telse: \n\t\t\treturn (self.end < item <= self.start and (self.start - item) % abs(self.step) == 0)\n```\n\n**Mappings** - container types that associate keys with values. They implement mapping protocol:\n`__getitem__(key)`, `__setitem__(key, value)` `__delitem__(key)`, `__contains__(key)`, `__len__()`\n\n```python\nclass MultiDict:\n    def __init__(self):\n        self._data = {}\n    \n    def __setitem__(self, key, value):\n        if key in self._data:\n            if not isinstance(self._data[key], list):\n                self._data[key] = [self._data[key]]\n            self._data[key].append(value)\n        else:\n            self._data[key] = value\n    \n    def __getitem__(self, key):\n        return self._data[key]\n    \n    def get_all(self, key):\n        value = self._data.get(key, [])\n        return value if isinstance(value, list) else [value]\n\n# Usage\nmd = MultiDict()\nmd['color'] = 'red'\nmd['color'] = 'blue'\nprint(md['color'])           # ['red', 'blue']\nprint(md.get_all('color'))   # ['red', 'blue']\n```",
      "type": "text",
      "width": 974,
      "x": -7313,
      "y": 11538
    },
    {
      "height": 1668,
      "id": "d42c79fa7adb520c",
      "styleAttributes": {
      },
      "text": "### Common patters\n\n### Run Multiple Tasks\n\npython\n\n```python\n# Wait for all to complete\nresults = await asyncio.gather(task1(), task2(), task3())\n\n# Handle exceptions individually\nresults = await asyncio.gather(*tasks, return_exceptions=True)\n\n# Create tasks first, then await\ntasks = [asyncio.create_task(func()) for func in functions]\nresults = await asyncio.gather(*tasks)\n```\n\n### Timeout Handling\n\npython\n\n```python\ntry:\n    result = await asyncio.wait_for(slow_function(), timeout=5.0)\nexcept asyncio.TimeoutError:\n    print(\"Operation timed out\")\n```\n\n### Rate Limiting\n\npython\n\n```python\nsemaphore = asyncio.Semaphore(5)  # Max 5 concurrent operations\n\nasync def limited_operation():\n    async with semaphore:\n        return await actual_operation()\n```\n\n### Producer/Consumer with Queue\n\npython\n\n```python\nqueue = asyncio.Queue(maxsize=10)\n\n# Producer\nawait queue.put(item)\n\n# Consumer  \nitem = await queue.get()\nqueue.task_done()\n\n# Wait for all items to be processed\nawait queue.join()\n```\n\n## Error Handling Patterns\n\npython\n\n```python\n# Individual task error handling\ntry:\n    result = await risky_operation()\nexcept SpecificError as e:\n    handle_error(e)\n\n# Gather with exception handling\nresults = await asyncio.gather(*tasks, return_exceptions=True)\nfor result in results:\n    if isinstance(result, Exception):\n        print(f\"Error: {result}\")\n```\n\n## Quick Comparison\n\n|Synchronous|Asynchronous|\n|---|---|\n|`time.sleep()`|`await asyncio.sleep()`|\n|`requests.get()`|`await session.get()`|\n|`open()`|`async with aiofiles.open()`|\n|`with`|`async with`|\n|`for`|`async for`|",
      "type": "text",
      "width": 803,
      "x": 5398,
      "y": 9238
    },
    {
      "height": 1668,
      "id": "0522ae3ba2eaa66d",
      "styleAttributes": {
      },
      "text": "### asyncio 1\n\n1\\. Event loop - keeps track of all tasks, decides what to do next, ensures that everything runs smoothly\n\n2\\. Coroutines - special functions that can pause and resume their exectution. \n\n3\\. Awaitable objects - things that you can \"await\" - operations that take time and can be paused. \n\n**Core Keywords**\n- `async def`\nDefines a coroutine function (returns a coroutine function when called)\n- `await`\nPauses execution until the awaitable completes; can only be inside async\n- `async with`\nContext manager for resources that need async setup/cleanup\n```python\nasync with aiohttp.ClientSession() as session:\n    response = await session.get(url)\n```\n- `async for`\nIterate over async iterators\n```python\nasync for item in async_generator(): \n\tprint(item)\n```\n\n**Essential methods**\n- Event loop management\n```python\nasyncio.run(coroutine)           # Run coroutine in new event loop (Python 3.7+)\nasyncio.get_event_loop()         # Get current event loop (deprecated)\nasyncio.create_task(coroutine)   # Schedule coroutine as task\n```\n\n- Concurrency control\n\n```python\nasyncio.gather(*coroutines)      # Run multiple coroutines concurrently\nasyncio.wait(tasks)              # Wait for tasks with more control\nasyncio.as_completed(tasks)      # Iterate over tasks as they complete\n```\n\n- Timing and delays\n```python\nasyncio.sleep(seconds)           # Async sleep (non-blocking)\nasyncio.wait_for(coro, timeout) # Run with timeout\n```\n\n- Synchronization Primitives\n```python\nasyncio.Semaphore(n)            # Limit concurrent access to n\nasyncio.Lock()                  # Async mutex lock\nasyncio.Event()                 # Async event signaling\nasyncio.Queue()                 # Async queue for producer/consumer\n```\n\n- Task management\n```python\ntask = asyncio.create_task(coro)     # Create and schedule task\ntask = asyncio.ensure_future(coro)   # Legacy way (still works)\n```\n```python\ntask.cancel()                   # Cancel task\ntask.cancelled()                # Check if cancelled\ntask.done()                     # Check if completed\ntask.result()                   # Get result (or exception)\n```",
      "type": "text",
      "width": 702,
      "x": 4647,
      "y": 9238
    },
    {
      "height": 1730,
      "id": "7cdaeb073d4fe29e",
      "styleAttributes": {
      },
      "text": "### First API\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# Path parameter - part of the URL structure\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    return {\"user_id\": user_id, \"name\": f\"User {user_id}\"}\n\n# Query parameters - optional parameters after the ?\n@app.get(\"/items/\")\ndef get_items(skip: int = 0, limit: int = 10):\n    return {\"skip\": skip, \"limit\": limit}\n\n# Combining both\n@app.get(\"/users/{user_id}/items/\")\ndef get_user_items(user_id: int, skip: int = 0, limit: int = 10):\n    return {\n        \"user_id\": user_id,\n        \"items\": f\"Items {skip} to {skip + limit}\",\n        \"skip\": skip,\n        \"limit\": limit\n    }\n```\n**The Theory Behind URL Design:**\n\n- **Path Parameters** represent the resource hierarchy (like folders in a file system)\n- **Query Parameters** represent filters or options for that resource\n- Good URL design makes your API intuitive: `/users/123/orders?status=pending` clearly means \"get pending orders for user 123\"\n#### HTTP Methods and Their Purposes\n\nEach HTTP method has a semantic meaning in REST:\n\npython\n\n```python\nfrom fastapi import FastAPI\nfrom typing import Dict\n\napp = FastAPI()\n\n# In-memory storage for demonstration\nfake_users_db: Dict[int, dict] = {}\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    \"\"\"Retrieve a user - READ operation\"\"\"\n    if user_id in fake_users_db:\n        return fake_users_db[user_id]\n    return {\"error\": \"User not found\"}\n\n@app.post(\"/users/\")\ndef create_user(user_data: dict):\n    \"\"\"Create a new user - CREATE operation\"\"\"\n    user_id = len(fake_users_db) + 1\n    fake_users_db[user_id] = user_data\n    return {\"user_id\": user_id, **user_data}\n\n@app.put(\"/users/{user_id}\")\ndef update_user(user_id: int, user_data: dict):\n    \"\"\"Update a user completely - UPDATE operation\"\"\"\n    fake_users_db[user_id] = user_data\n    return {\"user_id\": user_id, **user_data}\n\n@app.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int):\n    \"\"\"Delete a user - DELETE operation\"\"\"\n    if user_id in fake_users_db:\n        del fake_users_db[user_id]\n        return {\"message\": \"User deleted\"}\n    return {\"error\": \"User not found\"}\n```",
      "type": "text",
      "width": 718,
      "x": 4647,
      "y": 12994
    },
    {
      "height": 2481,
      "id": "82adab3162d2c35c",
      "styleAttributes": {
      },
      "text": "### Data validation with Pydantic\n\nIn real applications, you can't trust that incoming data will be in the correct format. Pydantic models act like contracts - they define exactly what your API expects and automatically validate incoming data.\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, EmailStr, validator\nfrom typing import Optional\nfrom datetime import datetime\n\napp = FastAPI()\n\n# Define what a User should look like\nclass UserCreate(BaseModel):\n    name: str\n    email: EmailStr\n    age: int\n    is_active: bool = True\n    \n    # Custom validation\n    @validator('age')\n    def validate_age(cls, v):\n        if v < 0 or v > 150:\n            raise ValueError('Age must be between 0 and 150')\n        return v\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    email: str\n    age: int\n    is_active: bool\n    created_at: datetime\n\n# In-memory database\nfake_db = {}\nuser_counter = 1\n\n@app.post(\"/users/\", response_model=UserResponse)\ndef create_user(user: UserCreate):\n    global user_counter\n    \n    # Create user with auto-generated fields\n    user_data = user.dict()\n    user_data.update({\n        \"id\": user_counter,\n        \"created_at\": datetime.now()\n    })\n    \n    fake_db[user_counter] = user_data\n    user_counter += 1\n    \n    return user_data\n```\n\n**The Power of This Approach:**\n\n1. **Automatic Validation**: FastAPI automatically validates that incoming JSON matches your model\n2. **Type Safety**: Your editor can provide autocomplete and catch errors\n3. **Documentation**: Your API docs automatically show the expected request/response format\n4. **Serialization**: Pydantic handles converting between Python objects and JSON\n\n#### Advanced Pydantic Features\n\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom enum import Enum\n\nclass UserRole(str, Enum):\n    ADMIN = \"admin\"\n    USER = \"user\"\n    MODERATOR = \"moderator\"\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n    postal_code: str = Field(..., min_length=3, max_length=10)\n\nclass User(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: EmailStr\n    age: int = Field(..., gt=0, le=150)\n    role: UserRole = UserRole.USER\n    address: Optional[Address] = None\n    tags: List[str] = []\n    \n    class Config:\n        # This allows the model to work with ORM objects\n        orm_mode = True\n        \n        # Example data for documentation\n        schema_extra = {\n            \"example\": {\n                \"name\": \"John Doe\",\n                \"email\": \"john@example.com\",\n                \"age\": 30,\n                \"role\": \"user\",\n                \"address\": {\n                    \"street\": \"123 Main St\",\n                    \"city\": \"New York\",\n                    \"country\": \"USA\",\n                    \"postal_code\": \"10001\"\n                },\n                \"tags\": [\"developer\", \"python\"]\n            }\n        }\n```",
      "type": "text",
      "width": 622,
      "x": 5398,
      "y": 12701
    },
    {
      "height": 709,
      "id": "6af2e4f9ab19508c",
      "styleAttributes": {
      },
      "text": "### FastAPI\n\nFastAPI is a modern Python web framework designed specifically for building APIs\n\nFastAPI was built with three core principles that solve common problems in API development:\n\n1. **Performance**: It's built on Starlette (for web handling) and Pydantic (for data validation), making it as fast as NodeJS and Go\n2. **Developer Experience**: Automatic interactive documentation, type hints, and intelligent auto-completion\n3. **Standards Compliance**: Built on OpenAPI and JSON Schema standards, ensuring your API works well with other tools\n\n```bash\npip install fastapi uvicorn sqlalchemy psycopg2-binary python-multipart\n```\n\n- **FastAPI**: The main framework for building our API\n- **Uvicorn**: An ASGI server that runs our FastAPI application (think of it as the engine that powers your API)\n- **SQLAlchemy**: An Object-Relational Mapping (ORM) tool that lets us work with databases using Python objects instead of raw SQL\n- **psycopg2-binary**: A PostgreSQL adapter (we'll also show SQLite examples for simplicity)\n- **python-multipart**: Handles file uploads and form data\n\n\n",
      "type": "text",
      "width": 718,
      "x": 4647,
      "y": 11217
    },
    {
      "color": "6",
      "height": 753,
      "id": "857ee379fc684e62",
      "styleAttributes": {
      },
      "text": "### Память\n\n",
      "type": "text",
      "width": 556,
      "x": -8286,
      "y": 8445
    },
    {
      "height": 2491,
      "id": "aab62b2a4903ff57",
      "styleAttributes": {
      },
      "text": "### Classes\n\nClass variable vs. instance variable\n```python\nclass BankAccount: # Class variable - shared by ALL instances \n\tbank_name = \"Python Bank\" \n\ttotal_accounts = 0 \n\tinterest_rate = 0.02 # 2% interest for all accounts \n\t\n\tdef __init__(self, owner, initial_balance=0): # Instance variables - unique to each object \n\t\tself.owner = owner \n\t\tself.balance = initial_balance \n\t\tself.account_number = f\"ACC{BankAccount.total_accounts + 1:04d}\"\n```\n\nInstance, class and static methods\n\n```python\n# INSTANCE METHOD - most common type \n# - Takes 'self' as first parameter \n# - Can access both instance AND class variables \n# - Called on specific instances \ndef area(self): \n\t\"\"\"Calculate area using instance data\"\"\" \n\treturn Circle.pi * self.radius ** 2\n\n# CLASS METHOD - works with the class itself \n# - Takes 'cls' as first parameter (the class, not an instance) \n# - Can access class variables but NOT instance variables \n# - Often used for alternative constructors or class-level operations \n@classmethod \ndef from_diameter(cls, diameter): \n\t\t\"\"\"Alternative constructor: create circle from diameter instead of radius\"\"\" \n\t\tradius = diameter / 2 \n\t\treturn cls(radius) # cls refers to Circle class\n\n# STATIC METHOD - independent utility function \n# - No automatic first parameter (no self or cls) \n# - Cannot access instance OR class variables directly \n# - Behaves like a regular function, but organized within the class \n# - Used for utility functions related to the class concept\n@staticmethod \ndef calculate_area_from_radius(radius): \n\t\"\"\"Calculate area without needing a Circle instance\"\"\" \n\tif not Circle.is_valid_radius(radius): \n\t\traise ValueError(\"Invalid radius\") \n\t\treturn math.pi * radius ** 2 # Using math.pi instead of class variable\n```\n\nProperty decorators \n```python\ndef __init__(self, celsius=0): \n\tself._celsius = celsius # Private attribute with underscore\n\n@property \ndef celsius(self): \n\t\"\"\"Get temperature in Celsius\"\"\" \n\tprint(f\"Getting celsius: {self._celsius}\") # For demonstration return self._celsius\n\n@celsius.setter # temp.celcius = 0\ndef celsius(self, value): \n\t\"\"\"Set temperature in Celsius with validation\"\"\" \n\tprint(f\"Setting celsius to: {value}\") # For demonstration \n\tif not isinstance(value, (int, float)): \n\t\traise TypeError(\"Temperature must be a number\") if value < -273.15: # Absolute zero check raise \n\t\tValueError(\"Temperature cannot be below absolute zero (-273.15°C)\") \n\t\tself._celsius = value\n\n@celsius.deleter \ndef celsius(self): # del temp.celcius\n\t\"\"\"Delete temperature (reset to 0)\"\"\" \n\tprint(\"Deleting celsius temperature\") \n\tself._celsius = 0\n```\nDescriptors\n```python\nclass LoggedAttribute:\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, instance, owner):\n        value = instance.__dict__.get(self.name)\n        print(f\"[GET] {self.name} = {value}\")\n        return value\n\n    def __set__(self, instance, value):\n        print(f\"[SET] {self.name} = {value}\")\n        instance.__dict__[self.name] = value\n\nclass Person:\n    age = LoggedAttribute(\"age\")\n\np = Person()\np.age = 30      # [SET] age = 30\nprint(p.age)    # [GET] age = 30 → 30\n\n```\n\n`__slots__`\n```python\nclass RegularPoint: \n\t\"\"\"A regular class without __slots__ - uses __dict__ for attribute storage\"\"\" \n\tdef __init__(self, x, y): \n\t\tself.x = x self.y = y \n\t\n\tdef distance_from_origin(self): \n\t\treturn (self.x ** 2 + self.y ** 2) ** 0.5\n\nclass SlottedPoint: \n\t\"\"\"A class with __slots__ - uses fixed memory layout\"\"\" \n\t__slots__ = ['x', 'y'] # Only these attributes are allowed \n\t\n\tdef __init__(self, x, y): \n\t\tself.x = x self.y = y \n\t\t\n\tdef distance_from_origin(self): \n\t\treturn (self.x ** 2 + self.y ** 2) ** 0.5\n```",
      "type": "text",
      "width": 974,
      "x": -7309,
      "y": 13373
    },
    {
      "color": "6",
      "height": 945,
      "id": "a255e33be1b28648",
      "styleAttributes": {
      },
      "text": "### Функции 1\n\n**Просто функции**: \n```python\ndef f(arg1: type1, ..., darg1: dtype1 = val1, ..., *args, **kwargs):\n\t...\n```\n\n**Лямбда**: `lambda args: expression` \nNot expression (operator?) => SyntaxError\n\n\\* map, filter, reduce",
      "type": "text",
      "width": 457,
      "x": -6298,
      "y": 8249
    },
    {
      "height": 1737,
      "id": "2330aa6210940db0",
      "styleAttributes": {
      },
      "text": "### Dunder methods\n**Dunder methods** (double underscore) - python's special methods that allow to define how objects behave with built-in operations and functions. `__methodname__`. \"Magic methods\"\n\n**Core concept**\nWhen writing `len(my_list)` or `my_list + other list`, python doesn't automatically know what to do. Looks for specific dunder methods on the objects (`__len__`, `__add__`)\n\n**Object lifecycle methods**\nHow objects are created, represented and destroyed\n`__init__`, `__str__`, `__repr__`, `__del__` (str readable for users, repr unambiguous for devs), `__hash__`\n\n**Comparison methods**\n`__eq__`, `__le__`, `__lt__`, `__gt__`, `__ge__`, `__ne__`\n\\* `@functools.total_ordering`\n\n**Arithmetic methods**\n`__add__`, `__sub__`, `__mul__`, `__rmul__`, `__truediv__`, `__abs__`, `__repr__`\n\n**Container methods**\n`__len__`, `__getitem__`, `__setitem__`, `__delitem__`, `__contains__`, `__iter__`\n\n**Context manager methods**\n`__enter__`, `__exit__`\n\n**Callable metohds**\n`__call__`",
      "type": "text",
      "width": 1040,
      "x": -5340,
      "y": 11538
    },
    {
      "height": 517,
      "id": "8ddc3a9151a7498b",
      "styleAttributes": {
      },
      "text": "### Модули, пакеты\n\n- **Модуль** - функционеально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части. Модули позволяют разбивать сложные задачи на более мелкие в соответствии с принципом модульности. Файл с исходным кодом на python - модуль. Модули могут объединяться в пакеты и библиотеки\n- **Название** модуля в глобальной переменной `__name__`. Если не импортирован, а запущен как скрипт, то `__name__` устанавливается в `__main__`. \n- **Модульное программирование** - организация программы как совокупности небольших независимых блоков, нозываемых модулями, структура и поведение которых подчняются определённым правилам. \n- **Как python ищет модули**. При импортировании интерпретатор python ищет модули в директориях и архивах, список которых доступен в виде переменной path встроенного модуля sys. По умолчанию sys.path состоит из директории с запускаемым скриптом, содержимого переменнойокружения PYTHONPATH и стандартного расположеня модулей, специфичного для конкретной платформы и интерпретатора\n- **Пакеты.** Модули могут объединяться в пакеты. Служат как пространство имён для модулей.  Пакет - модуль. но не каждый модуль - пакет. Обычно модули предоставляются в виде файлов, а пакеты в виде каталогов в файловой системе. Чтобы каталог был пакетом, в нём должен находиться `__init__.py`. Он может быть пустым или содержать действия для инициализации.\n- `import package.item`. При использовании `from package import item`, item может быть пакетом, модулем или любым именем, описанным в пакете. При использовании import package.item, item должен быть модулем или пакетом",
      "type": "text",
      "width": 1090,
      "x": -3914,
      "y": 9238
    },
    {
      "height": 1147,
      "id": "c1d7005d21627c6a",
      "styleAttributes": {
      },
      "text": "### Исключения\n\n- **Обработка исключений** (exception handling) - механизм, предназначенный для описания реакции программы на ошибки во время выполнения и другие возможные проблемы, которые могут возникнуть при выполнении и приводят к невозможности дальнейшей отработки программой её базового алгоритма.\nraise Exception\n- Конструкция try finally без except\n```python\ntry:\n    # some code\nfinally:\n    # some code\n```\nЕсли в try произойдёт ошибка, то finally всё равно будет выполнен, и в нутри него можно будет сделать cleanup.\n- Блоки except обрабатываются сверху вниз, и управление передаётся не больше, чем одному обработчику. Сперва нужно указывать обработчики менее общих исключений, затем более общих. bar except может быть только последним\n- Если исключение не перехватится, то интерпретатор завершает выполнение и выводит информацию в sys.stderr. Два исключения: 1) если исключение в деструкторе объекта, выполнение не завершается, а в поток ошибок выводится предупреждение exception ignored с информацией об исключении, 2) при SystemExit происходит только заершение работы\n- Перехват исключения, выполнение действия и снова raise\n```python\ntry:\n\t1/0\nexcept ZeroDivisionError:\n\traise\n```\n\n- **Сцепление исключений**. В P3 при raise исключения в except стаоре сохраняется в атрибует __context__, и если новое не обработано, то будет выведена информация о том, что новое возникло при обработке старого.\n- `else` нужен, если в процессе выполнения `try` не возникло исключений\n- Исключения могут принимать в качестве параметра конструктора любые неименованные аргументы\n- Классы:\nБазовые:\nBaseException, Exception(BaseException), ArithmeticError, BufferError, LookupError\nНекоторые из конкретных стандартных:\nAssertionError, AttributeError, FloatingPointError, ImportError, IndexError, KeyboardInterrupt, MemoryError, NameError, NotImplementedError, OSError,OverflowError, RuntimeError, SyntaxError, IndentationError, TabError, SystemError, SystemExit, TypeError, UnboundLocalError, ValueError, ZeroDivisionError\n- Обработка SyntaxError - если ошибка синтаксиса в импортируемом модуле или коде, который представляется строкой и передаётся функции eval/exec\n- Кастомные исключения - наследники Exception\n- warnings - функции для работы с предупреждениямию. Основной является функция warn, которая принимает один обязательный параметр message, который может быть либо строкой-сообщением, либо экземпляром класса или подклассом Warning",
      "type": "text",
      "width": 1090,
      "x": -3914,
      "y": 9800
    },
    {
      "height": 1623,
      "id": "50c5d949d57c606a",
      "styleAttributes": {
      },
      "text": "### Классы, объекты\n- Список атрибутов объекта - dir, `__dict__`\n- **Магические (dunder) методы** - методы, имена которых начинаются и заканчиваются `__`. Почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. `len()` вызывает метод `__len__()`. `__add__(self, other)` вызывается автоматически при сложении оператором `+`.\n`__init__`, `__add__`, `__eq__`, `__iter__`\n- **Наследование**. Возможно указать более одного родителя\n```class NextClass(FirstClass):\n\tdef __init__(self, x):\n\t\tsuper(NextClass, self).__init__()\n\t\tself.x = x\n```\n**MRO** - method resolution order, порядок разрешения методов. Классика: Поиск: сперва экземпляр, потом класс, далее суперклассы с обходом сперва в глубину, а потом слева направо. Первое вхождение. DFLR. Diamond problem\n- **Миксин** (mix-in) - паттерно в ООП, когда в цепочку наследования добавляется небольшой класс-помощник\n```python\nclass NowMixin(object):\n    def now():\n        return datetime.datetime.utcnow()\n```\n- **Контекстный менеджер**. `with`. До и после гарантированно срабатывают события входа в `with` и выхода из него.\nВход: `__enter__`, выход: `__exit__`\n```python\nclass Printable:\n    def __enter__(self):\n        print('enter')\n\n    def __exit__(self, type, value, traceback):\n        print('exit')\n```\n\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef printable():\n    print('enter')\n    try:\n      yield\n    finally:\n      print('exit')\n```\n`object() == object()` - всегда False, по умолчанию объекты сравниваются по id (адрес в памяти), если не переопределён `__eq__`\n\n- `__slots__()` жестко фиксирует набор полей класса. Используются, когда у класса очень много полей (ORM), или когда критична производительность (случай с 1kk+ экземлпярами)\nНедостаток: нельзя присвоить классу поле, которого нет в слотах. Не работают `__getattr__` и `__setattr__`. Решение: включить в slots элемент dict\n\n- `_value`,`__value`. Одно подчёркивание - приватное поле, использование внутри модуля, класса или пакета.  Два подчёркиваня - триггерит поведение **name mangling**. `.__attribute` to `._SampleClass__attribute`\n- `__new__` vs `__init__`. `__new__` обрабатывает создание объекта, `__init__` - инициализацию. `__new__` при создании инстанса, `__init__` вызывается каждый раз, когда экземпляр возвращается `__new__`. Сперва `__new__`, потом `__init__`\n\n- **Duck typing** - вид динамической типизации, когда границы использования объекта определяются набором его текущих методов и свойств, в противоположность наследования от определённого класса.",
      "type": "text",
      "width": 1174,
      "x": -5147,
      "y": 9238
    },
    {
      "height": 622,
      "id": "34e97a50a21a87fb",
      "styleAttributes": {
      },
      "text": "### Функции\n\n- **args, kwargs**. `*args`, `**kwargs` объявляют в сигнатуре функции. Внутри функции будут доступны переменные с `args`, `kwargs`\n`args` - кортеж, который накапливает позционные аргументы, `kwargs` - словарь именованных аргументов\n- Использовать mutable в качестве параметра по умолчанию плохо\n```python\ndef foo(bar=None):\n    if bar is None:\n        bar = []\n    bar.append(1)\n    return bar\n```\n- **Лямбды** - анонимные функции, внутри может быть только выражение. `labmda args: expression`. \nok: Выражения 1+2, x if cond else y, func(x); not ok: операторы pass, raise, print, return, for, if (без else), while, try\n**Выражение** - конструкция, которая возвращает значение, **оператор** - конструкция, которая выполняет действие, но не возвращает значение (или возвращает None)\n- **Функции** - first class objects, можно присваивать, передавать в функцию, удалять\n- При вызове функций новых объектов не создаётся, но в области видимости создаётся новое имя, которое связывается с существующим объектом\n- **Замыкание** - синтаксически это функция внутри другой функции.  Вложенная функция содержит ссылки на локальные переменные внешней функции. При выполнении внешней функции происходит создание нового экземпляра внутренней функции",
      "type": "text",
      "width": 1106,
      "x": -6298,
      "y": 9238
    },
    {
      "height": 1434,
      "id": "d855e8e0805f0ed1",
      "styleAttributes": {
      },
      "text": "**Итераторы и генераторы**\n\n- **Контейнер** - тип данных, инкапсулирующий значения остальных типов (списки, кортежи, множества, словари)\n- **Итерабельный объект** (iterable) - объект, который может возвращать значения по одному. `__iter__()`, `__getitem__()`\n```python\nclass Iterable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __iter__(self):\n        while False:\n            yield None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterable:\n            return _check_methods(C, \"__iter__\")\n        return NotImplemented\n```\nЕсли `__iter__` не реализован, то проверяется `__getitem__` \n\n**Итератор** - объект, представляющий поток данных. `__next__()`, `__iter__()`, `StopIteration`\n```python\nclass Iterator(Iterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __next__(self):\n        'Return the next item from the iterator. When exhausted, raise StopIteration'\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterator:\n            return _check_methods(C, '__iter__', '__next__')\n        return NotImplemented\n```\n- **Генератор** - в зависимости от контекста либо функция-генератор, либо итератор генератора. iter, next создаются автоматически. Либо yield, либо генераторное выражение. Пример - бесконечные последовательности\nEx. `[x for x in y]` vs. `(x for x in y)`\n- **Генераторная функция** - функция, в теле которой встречается yield. yield замораживает состояние функции-генератора и возвращает текущее значение. После выполнение продолжается с прошлого места.\n- Генератор хранит не все элементы, а только внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий. \n- Объявление: генераторное выражение, yield в теле функции, встроенная функция iter\n- Подгенератор\n- send, throw, close\n- Не поддерживается `__getitem__`\n- При итерации по словарю в python 3.7+ порядок гарантируется\n- `.items()` возвращает генератор кортежей `(key, value)`\n- **Сопрограмма** - компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек, остановку и продолжение выполнения с сохранением определённого положения. Расширенные возможности генераторов используются для реализации корутин",
      "type": "text",
      "width": 1106,
      "x": -6280,
      "y": 9887
    },
    {
      "color": "6",
      "height": 753,
      "id": "47a1c5aa3bb09399",
      "styleAttributes": {
      },
      "text": "### Типы данных\n\n**Immutable**:\nInt, Float, Complex, None\nStr, Tuple, Frozenset\nBytes - байтовые строки\n\n**Mutable**:\nList, Set, Dict\ndefauldict, OrderedDict, ChainMap \n\n\\* Устройство хэш-таблицы\n- У каждого ключа вызывается `hash()`, получаем `int`\n- Массив `entries[]`, содержащий хэш, ключ и значение\n- `index = hash(key) % table_size`\n- Для разрешение коллизий  используется открытая индексация с квадраатичным пробингом\n- Автоматически расширяется, когда коэффициент загрузки превысит определённый порог, создаётся новая таблица\n```python\ni = hash % N\nj = 1\ni_next = (i + j^2) % N, j += 1\n```\n",
      "type": "text",
      "width": 366,
      "x": -7570,
      "y": 8445
    },
    {
      "color": "6",
      "height": 753,
      "id": "e4703063cd15e0d6",
      "styleAttributes": {
      },
      "text": "### Коллекции\n\n**Collection** - хранит набор значений одного или разных типов\n\n**Sequence** - доступ по индексу (`__getitem__`)\n**Containers** - проверка на in `__contains__`\n**Mapping** - `keys`, `values`, `items`\n\n**Iterable** - объект, по которому можем итерироваться (`__iter__`)\n**Iterator** - объект (`__iter__`, `__next__`), который возвращает значения по одному\n\\* StopIteration",
      "type": "text",
      "width": 464,
      "x": -7161,
      "y": 8445
    },
    {
      "color": "6",
      "height": 753,
      "id": "70648b1d58df978e",
      "styleAttributes": {
      },
      "text": "### Comprehensions\n\nList, dict, set; + generator expression\n\n`[x for x in iterable if condition]`",
      "type": "text",
      "width": 291,
      "x": -6667,
      "y": 8445
    },
    {
      "color": "6",
      "height": 949,
      "id": "26cca098e078d8b0",
      "styleAttributes": {
      },
      "text": "### Функции 2\n\n**Генераторы**\n```python\ndef gen(f, obj):\n    for x in obj:\n        yield f(x)\n```\n**Замыкания**\n```python\ndef outer(a=1):\n\tdef inner(b=2):\n\t\treturn a + b\n\treturn inner\nprint(outer(2)(3))\n```\n**Декораторы**\n```python\nfrom functools import wraps\n\ndef deco_name(params):\n\tdef decorator(func):\n\t\t@wraps(func)\n\t\tdef wrapper(*args, **kwargs):\n\t\t\t# logic\n\t\t\tres = func(*args, **kwargs)\n\t\t\t# logic\n\t\t\treturn res\n\t\treturn decorator\n\treturn wrapper\n\n@deco_name\ndef function(...):\n\t...\n```",
      "type": "text",
      "width": 576,
      "x": -5790,
      "y": 8249
    },
    {
      "color": "6",
      "height": 945,
      "id": "05117a1855a254b8",
      "styleAttributes": {
      },
      "text": "### Классы 1\n\n**Attributes, methods**\n```python\nclass MyClass:\n\tclass_var = 0\n\tdef __init__(self, arg):\n\t\tsuper().__init__()\n\t\tself.arg = arg\n\tdef instace_method(self, arg):\n\t\t...\n\t@classmethod\n\tdef class_method(cls, arg):\n\t\tMyClass.class_var = 1\n\t@staticmethod\n\tdef static_method(arg):\n\t\t...\nMyClass.static_method(arg)\ninst = MyClass(arg)\ninst.static_method(arg)\n```\n**Private, protected, public; setters and getters**\n```python\nclass MyClass:\n    def __init__(self):\n        self.public = 1\n        self._protected = 2\n        self.__private = 2\n    @property\n    def protected(self):\n        return self._protected\n    @protected.setter\n    def protected(self, arg):\n        if type(arg) == int:\n            self._protected = arg\n    @protected.deleter\n    def protected(self):\n        self._protected = 0\n```",
      "type": "text",
      "width": 510,
      "x": -5147,
      "y": 8253
    },
    {
      "height": 945,
      "id": "c0e41933be05516d",
      "styleAttributes": {
      },
      "text": "### I/O",
      "type": "text",
      "width": 889,
      "x": -1813,
      "y": 8249
    },
    {
      "height": 945,
      "id": "41c59a390c82afbc",
      "styleAttributes": {
      },
      "text": "### Исключения\n\n```python\ntry:\n\t...\nexcept:\n\t...\nfinally:\n\t...\n```\n\n\n\nBaseException, Exception, ....",
      "type": "text",
      "width": 780,
      "x": -2638,
      "y": 8249
    },
    {
      "height": 945,
      "id": "257d2195ef122002",
      "styleAttributes": {
      },
      "text": "### Асинхронность",
      "type": "text",
      "width": 1292,
      "x": -37,
      "y": 8249
    },
    {
      "color": "6",
      "height": 945,
      "id": "9e4009e6c67e9270",
      "styleAttributes": {
      },
      "text": "### Контекстные менеджеры \n",
      "type": "text",
      "width": 773,
      "x": -864,
      "y": 8249
    },
    {
      "height": 1169,
      "id": "51b4657b8c03c496",
      "styleAttributes": {
      },
      "text": "### Функциональное программирование\n- **ФП** - раздел ДМ и парадигма программирования, в которой процесс вычисления траактуется как вычисление значений функций в математическом понимании последних. Протиповопоставляется парадигме императивного программирования \n- Python часично поддерживает парадигму ФП и повзоляет писать кода в ФП-стиле\n- Объект первого класса - сущности, которые могут быть передааны как параметр, возвращены из функции, присвоены переменной: 1) сохранен в переменной, 2) может быть передан в функцию как аргумент, 3) может быть возвращен из функции как рзультат, 4) может быть создан во время исполнения программы, 5) внутренне самоидентифицируем \n- **Функция высшего порядка** - функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата\n- **Каррирование** - преобразование функции от многих аргументов в набор функций, каждая из которых является функцией от одного аргумента. \n```python\ndef greet(greeting, name):\n    print(greeting + ', ' + name)\n\ngreet('Hello', 'German')\n```\n```python\ndef greet_curried(greeting):\n    def greet(name):\n        print(greeting + ', ' + name)\n    return greet\n\ngreet_hello = greet_curried('Hello')\n\ngreet_hello('German')\ngreet_hello('Ivan')\n```\n- Map, filter, reduce\n `map` применяет функцию к каждому элементу последовательности. Возвращает объект-итератор\n `filter` оставляет лишь те элементы последовательности, для которых заданная функция истинна \n `reduce` принимает функцию от двух аргументов, последовательности и опциональное начальное значение и вычисляет свёртку (fold)\n- Другие функции:\nlru_cache - декоратор, который кеширует значения функций, которые не меняют свой результат при неизменных аргументах (мемоизация)\n partial - частичное применение функции, получение функции, которая принимает оставшиеся параметры\n- Itertools\nproduct, permutations, combinations(with_replacement), chain, takewhile, dropwhile\n- operator содержит функции, которые соотвествуют стандартным операторам. Вместо lambda x, y: x + y можно использовать operator.add",
      "type": "text",
      "width": 812,
      "x": -719,
      "y": 9238
    },
    {
      "height": 888,
      "id": "c3413a133085e071",
      "styleAttributes": {
      },
      "text": "### GIL, потоки, процессы\n- **GIL (Global Interpreter Lock), проблемы**\nВ любой момент может выполняться только один поток Python. Глобальная блокировка интерпретатора - GIL- тщательно контролирует выполнение тредов. GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора (и соотвествующие вызовые C-расширений работают правильно).\n\n**Принцип работы**. Потоки удерживают GIL, пока выполняются. Однако они освобождают его при блокировании для операций ввода-вывода. Каждый раз, когда поток вынужден ждать, другие, готовые к выполнению, запускаются. \nКогда поток начинает работу, он захватывает GIL. Спустя некоторое время планировщик процессов решает, что текущий поток поработал достаточно, и передает управление следующему потоку. Поток 2 видит, что GIL захвачен, засыпает\nПоток не может удерживать GIL бесконечно. 5мс. Из-за GIL далеко не все задачи могут быть решены в тредах.\nGIL упрощает интеграцию non thread safe библиотек на С. Благодаря GIL у нас так много быстрых модулей и биндингов почти ко всему.\nБиблиотекам на C доступен механизм управления GIL. Так например NumPy отпускает его на долгих операциях.\nПо сути, GIL в питоне делает бесполезной идею применять потоки для параллелизма в вычислительных задачах. Они будут работать последовательно даже на многопроцессорной системе. На CPU Bound задачах программа не ускорится, а только замедлится, так как теперь потокам придется делить пополам процессорное время. При этом I/O операции GIL не замедлит, так как перед системным вызовом поток отпускает GIL.",
      "type": "text",
      "width": 812,
      "x": -719,
      "y": 10435
    },
    {
      "height": 861,
      "id": "6f24a33a5a1bbf78",
      "styleAttributes": {
      },
      "text": "### Ввод-вывод\n- **Файловый объект** - объект, предоставляющий файл-ориентированный API (методы read, write и тд) для доступа к ресурсу. В завимости от создания, файловый объект может предоставлять доступ к реальному ресурсу на диске или другому виду устройства хранения или передачи данных (stdin, буферы в памяти, сокеты и пр). Файловые объекты также называются потоками. ФИ являются контекстными менеджерами.\n- text files, raw binary files, buffered binary files. Текстовые файлы записывают и считывают данные типа str и автоматически выполняют преобразования кодировок и концов строк. Бинарные файлы записывают и считывают данные типов bytes  bytearray и не производят никаких манипуляций с данными\n- `open(file, mode='r', buffering=-1, encodeing=None, errors=None, newline=None, closefd=True, opener=None)`\nbuffering – использовать ли буферизацию: отрицательное число (по умолчанию, указывать явно не нужно) – стандартное значение для данного вида файлового объекта, 0 – отключить буферизацию, 1 – построчная буферизация (для текстовых файлов), другое значение – включить буферизацию и задать соответствующий размер буфера\nmode: r, w, x, a, t. + для чтения и записи одновременно. rb+\n- close - для записи (данные записываются не сразу; при вызове flush или close). Пока открыт, то заблокирован для w-открытия другими процессами до закрытия.\n- tell() - текущая позиция считывания/записи в файле. seek(offset, whence) устанавливает позицию.\n- io.StringIO и io.BytesIO - потоки для считывания и записи в строки или байтовые строки в памяти. \n- **Сериализация** - процесс сохранения объектов в бинарном или строковом виде для хранения, передачи и восстановления. Обратный процесс - десериализация. \n- **json.dumps / json.dump , json.loads / json.load** \ndumps сохраняет json-представление объекта в строку. dump - в текстовый файл. loads загружает из строки, load из текстового файла\n- **pickle.dumps / pickle.dump, pickle.loads / pickle.load** работают с байтовыми строками и бинарными файлами",
      "type": "text",
      "width": 854,
      "x": -1624,
      "y": 9238
    },
    {
      "height": 1168,
      "id": "8ddca698b4182254",
      "styleAttributes": {
      },
      "text": "### Тестирование\n- **Mocking** - если нужно тестировать функцию, то всё, что не относиться к ней самой, можно подменить пустышками. При этом тестируемые функции не нужно адаптировать для тестов. \n- **Тестируемая функция использует удаённое подключение к внешним сервисам**\nНужно либо замокать http-клиент, либо передавать то, что вызывает этот сервис в функцию зависимостью\n- **Тестируемая функция занимает много времени на выполнение повторяющихся операций**\nЛибо декомпозировать (если можно), либо а) заменить верхнюю границу цикла, если не влияет, б) если вызывает стороннюю функцию, то замокать её, в) по возможности для тестов набор данных, на котором выполняется быстро\n- **Виды тестов**\n1) **Unit-тесты**: модульные тесты проверяют, правильно ли работает каждый отдельный модуль (юнит)  кода. В идеале при планировании и написании модульных тестов нужно изолировать функционал, кторый нельзя разделить на более мелкие составляющие и протестировать его. Модульные тесты не должны проверять внешние зависимости или взаимодействия. Нужен мокинг api вызовов. Возможно, имитация вызовов базы данных. Должны быть быстрыми. Придумывать и писать параллельно с кодом\n2) **Интеграционные тесты (Integration tests)** - к тестам, покрывающим непосредственно публичный API сервиса. Фокус на проверку взаимодействия разных систем по принципу \"сервис-клиент\". Интеграционные тесты **проверяют взаимодействие между двумя+ отдельными модулями кода**. Приложение состоит из отдельных модулей, выполняющих определённые маленькие функции. Кажыдй из них может хорошо работать в изолированном состоянии, но ломаться в связке с другими. + проверка интеграции с внешними зависимостями. **Это следующий шаг после модульных тестов**. Провал тестов означает, что 2+ функции приложения не работают вместе. Это могут быть два написанных модуля, которые входят в противоречие из-за какой-то сложной бизнес логики. \n3) **Функциональное тестирование** - тестирование отдельных функций модулей. Относится к тестированию программного продукта на индивидуальном уровне. чтобы проверить его функциональность. Сильно отличается от модульного или интеграционного. Более сложное, чем модульное. Инструменты стремятся проверить функциональные возможности по. Тестовые примеры используются для проверки ожидаемых и неожиданных результатов тестирования. Больше с т.з. пользователя. \n4) **Системные тесты** - проверяют работу всей системы. Предельный случай интеграционных тестов. Не проверяют бизнес-правила напрямую, виесто этого проверяют, что компоненты системы правильно связаны друг с другом, а взаимодействие между ними происходит по исходному плану. Для небольших проектов это, как правило ручное тестирование. Подходы к автоматизации: пишутся системными архитекторами и ведущими специалистами с технической стороны. Выполняются относительно редко.\n5) **Проверка работоспособности (smoke test, sanity check)**. Частный случай интеграционного теста. Очень небольшие тесты, которые прогоняются перед запуском системы, чтобы убедиться в работоспособности стороннего ПО, которое необходимо для корректного функционирования системы. \n6) **Регрессионное тестирование** - любой вид теста из описанных выше, который пишется после того, что что-то сломалось.",
      "type": "text",
      "width": 854,
      "x": -1624,
      "y": 10124
    },
    {
      "height": 1079,
      "id": "1ae66968a149f161",
      "styleAttributes": {
      },
      "text": "### Декораторы\n- **Декоратор** - паттерн проектирования, когда один объект изменяет поведение другого. В Python декоратор, как правило, это функция A, которая принимает функцию B и возвращает функцию C. При этом C задействует в себе B.\n- **Декоратором может быть любой вызываемый объект**. Функция, лямбда, класс, экземпляр класса (в последнем случае нужен `__call__`). Применять можно к любому объекту, чаще всего к функциям, методам и классам. Оператор @\n```python\ndef auth_only(view):\n\t...\n@auth_only \ndef dashboard(request):\n\t...\n```\nБез @: \n```python\ndef auth_only(view):\n\t...\ndef dashboard(request):\n\t...\ndashboard = auth_only(dashboard)\n```\n- Если нет`return`, то вызов вернёт None. Результат декоратора замещает декорируемый объект.\n- @foobar - обычное декорирование функцией foobar, второй случай - декорирование функцией, которую вернёт вызов foobar. Параметрический декоратор/фабрика декораторов\n- **Фабрика декораторов** - функция, которая возвращает декоратор\n```python\nfrom functools import wraps\n\ndef has_perm(perm):\n\tdef decorator(view):\n\t\t@wraps(view)\n\t\tdef wrapper(request):\n\t\t\tif perm in request.user.permissions:\n\t\t\t\treturn view(request)\n\t\t\telse:\n\t\t\t\treturn HTTPRedirect('/login')\n\t\treturn wrapper\n\treturn decorator\n\n@has_perm('view_user')\ndef users(request):\n\t...\n```\n- **wraps** - декоратор из стандартной поставки Python, модуль functools. Он назначает функции-врапперу те же поля `__name__`, `__module__`, `__doc__`, что и у исходной декорируемой функции",
      "type": "text",
      "width": 1115,
      "x": -2770,
      "y": 9238
    },
    {
      "height": 786,
      "id": "1fd70dcaccfcbfa4",
      "styleAttributes": {
      },
      "text": "### Метаклассы\n\n- **Метакласс** - ООП концепт: элемент для создания классов. \n- **type**. `type` - метакласс, который python внутренне использует для создания всех классов\n```python\nclass Foo(Bar):\n\tpass\n```\nPython делает следующее:\n1) Есть ли у Foo `__metaclass__`?\n2) Если да, то создаёт в памяти объект-класс с именем Foo, используя то, что указано в `__metaclas__`\n3) Если python не находит `__metaclass__`, то ищет в родительском `Bar`\n4) Если не может найти ни одного `__metaclass__`, то использует type\n\n- **Работа метаклассов**: перехват создния классов, изменение класса, возвращение модифицированного\n- **Использование метаклассов**\nОсновное применение - создание API. Пример - Django ORM.\n```python\nclass Person(models.Model):\n  name = models.CharField(max_length=30)\n  age = models.IntegerField()\n```\nПри выполнении\n```python\nguy = Person(name='bob', age='35')\nprint guy.age\n```\nполучаем `int`. Это возможно, потому что `models.Model` определяет `__metaclass__`, который сотворит некоторую магию и превратит класс `Person` в сложную привязку к бд",
      "type": "text",
      "width": 1115,
      "x": -2770,
      "y": 10343
    },
    {
      "height": 1139,
      "id": "03a1dba04a455171",
      "styleAttributes": {
      },
      "text": "### Dict\n\n#### just dict\n\n'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'\n\nkeys, items, values, get\nupdate\npop, clear, popitem\ncopy\n\n#### defaultdict\n```python\nfrom collections import defaultdict as dd\nd = dd(int) # dd(list), dd(str)\n```\ndefault_factory\nsetdefault\n\n#### OrderedDict\n```python\nfrom collections import OrderedDict\n\nordered_menu = OrderedDict([\n    ('appetizer', 'salad'),\n    ('main', 'pasta'),\n    ('dessert', 'cake')\n])\n\nordered_menu.move_to_end('appetizer')  # Moves to end\nordered_menu.move_to_end('main', last=False)  # Moves to beginning\n\nfirst_course = ordered_menu.popitem(last=False)  # ('main', 'pasta')\nlast_course = ordered_menu.popitem(last=True)    # ('dessert', 'cake')\n```\n\n#### ChainMap\n```python\nfrom collections import ChainMap\n\ncm = ChainMap(d1, d2, ...)\n\nactive_config = ChainMap(user_config, default_config)\nruntime_config = ChainMap(temp_overrides, user_config, default_config)\n\n```",
      "type": "text",
      "width": 838,
      "x": -1545,
      "y": 5306
    },
    {
      "height": 580,
      "id": "77aca62394be7a98",
      "styleAttributes": {
      },
      "text": "### Set\n`s = {1, 2, 3, 4}`\n\n'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update'\n\nadd, union\npop, remove, discard, clear\nintersection, intersection_update, difference, difference_update, symmetric_difference, symmetric_difference_update\nisdisjoint, issubset, issuperset\ncopy\n\n#### Frozenset: Immutable Sets for Special Cases\n\n- The same operations except for methods that would modify the set\n- Hashable",
      "type": "text",
      "width": 849,
      "x": -1545,
      "y": 4451
    },
    {
      "height": 488,
      "id": "2fe77443352508ee",
      "styleAttributes": {
      },
      "text": "### Tuple\n\n```python\na = (1,2,3)\n```\n'count', 'index'\n\n#### Named tuple\n```python\nfrom collections import namedtuple # Define a named tuple type \nPoint = namedtuple('Point', ['x', 'y']) \nPerson = namedtuple('Person', ['name', 'age', 'email'])\n\norigin = Point(0, 0) \nuser = Person('Alice Johnson', 28, 'alice@example.com')\n```\nNamed tuples are particularly valuable for functions that return multiple related values, making the code much more readable than returning plain tuples",
      "type": "text",
      "width": 838,
      "x": -2442,
      "y": 4451
    },
    {
      "height": 322,
      "id": "eda53391b48bc9d9",
      "styleAttributes": {
      },
      "text": "### List\n\nSlices: `l[start:stop:step]`. `[::-1`] is eq to `[-1:-len(l)-1:-1]`\n\nmethods: 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'\n\nadd: append, extend, insert\nremove: pop, remove, clear\nsearch/count: index, count\nreorder: sort, reverse\ncopy",
      "type": "text",
      "width": 838,
      "x": -2442,
      "y": 4993
    },
    {
      "height": 1010,
      "id": "912e7a75e15b8491",
      "styleAttributes": {
      },
      "text": "### Lambda Functions and Functional Programming Basics\nLambda functions are anonymous, single-expression functions. They're useful for short, simple operations that don't warrant a full function definition.\n\n```python\n# Regular function vs lambda\ndef square(x):\n    return x ** 2\n\n# Equivalent lambda\nsquare_lambda = lambda x: x ** 2\n\nprint(square(5))        # 25\nprint(square_lambda(5)) # 25\n\n# Lambdas are most useful in functional programming contexts\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # [1, 4, 9, 16, 25]\n```\n\n#### Functional Programming with Built-in Functions\n\n**Map, Filter, and Reduce**",
      "type": "text",
      "width": 1163,
      "x": -402,
      "y": 6615
    },
    {
      "height": 1184,
      "id": "f2de2f439516cf1b",
      "styleAttributes": {
      },
      "text": "### Decorators (Basic to Intermediate)\nDecorators are functions that modify or enhance other functions without changing their source code. They implement the decorator pattern and are applied using the `@` syntax.\n```python\ndef simple_timer(func):\n    \"\"\"A basic decorator that times function execution.\"\"\"\n    import time\n    \n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)  # Call the original function\n        end_time = time.time()\n        \n        print(f\"{func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    \n    return wrapper\n\n# Apply the decorator\n@simple_timer\ndef slow_function():\n    import time\n    time.sleep(1)\n    return \"Done!\"\n\n# This is equivalent to: slow_function = simple_timer(slow_function)\nresult = slow_function()  # Prints timing info and returns \"Done!\"\n```\n**Decorators with Arguments**\n```python\ndef retry(max_attempts=3, delay=1): \n\t\"\"\"Decorator that retries a function on failure.\"\"\" \n\tdef decorator(func): \n\t\tdef wrapper(*args, **kwargs):\n\t\t\t...\n\treturn wrapper\nreturn decorator\n```\n\n**Class-Based Decorators**, **Preserving Function Metadata**, **Chaining Multiple Decorators**\n\n### Key Insights for Decorators\n\n- Decorators modify functions without changing their source code\n- Use `@wraps(func)` to preserve original function metadata\n- Decorators with arguments require a three-level nested structure\n- Multiple decorators are applied bottom-up (innermost first)\n- Class-based decorators use `__call__` method and maintain state between calls",
      "type": "text",
      "width": 785,
      "x": 303,
      "y": 5350
    },
    {
      "height": 546,
      "id": "74cac1a951d8e61b",
      "styleAttributes": {
      },
      "text": "### Function Annotations and Type Hints\n\n```python\ndef calculate_average(numbers: List[float]) -> float: \n\t\"\"\"Calculate the average of a list of numbers.\"\"\" \n\tif not numbers: raise ValueError(\"Cannot calculate average of empty list\")         return sum(numbers) / len(numbers)\n```\n\n```python\nfrom typing import TypeVar, Generic, Protocol # Generic type for reusable functions \nT = TypeVar('T') \ndef safe_get_item(items: List[T], index: int, default: T) -> T: \n\t\"\"\"Safely get an item from a list with a default value.\"\"\" \n\ttry: \n\t\treturn items[index] \n\texcept IndexError: \n\t\treturn default\n```",
      "type": "text",
      "width": 785,
      "x": -535,
      "y": 5909
    },
    {
      "height": 1434,
      "id": "e1abc4429b1e73c6",
      "styleAttributes": {
      },
      "text": "### \\*args and \\*\\*kwargs\nThe `*args` and `**kwargs` syntax allows functions to accept variable numbers of arguments. Think of `*args` as a way to collect extra positional arguments into a tuple, while `**kwargs` collects extra keyword arguments into a dictionary\n\n```python\ndef basic_example(*args, **kwargs): \n\tprint(f\"Positional arguments: {args}\") \n\tprint(f\"Keyword arguments: {kwargs}\") \nbasic_example(1, 2, 3, name=\"Alice\", age=30)\n```\n\n**Argument Forwarding and Delegation**\n```python\nclass APIClient:\n    def __init__(self, base_url, timeout=30):\n        self.base_url = base_url\n        self.timeout = timeout\n    \n    def request(self, method, endpoint, *args, **kwargs):\n        # Forward all arguments to the underlying request library\n        # while adding our own processing\n        full_url = f\"{self.base_url}/{endpoint}\"\n        kwargs.setdefault('timeout', self.timeout)  # Set default if not provided\n        \n        print(f\"Making {method} request to {full_url}\")\n        print(f\"Additional args: {args}\")\n        print(f\"Request kwargs: {kwargs}\")\n        \n        # In real code, you'd call requests.request(method, full_url, *args, **kwargs)\n        return f\"Response from {full_url}\"\n\n# Usage demonstrates clean API design\nclient = APIClient(\"https://api.example.com\")\nclient.request(\"GET\", \"users\", headers={\"Auth\": \"Bearer token\"}, params={\"page\": 1})\n```\n\n**Flexible Configuration Systems**\n```python\ndef configure_database(host, port, database, **connection_options): \n\t\"\"\" Configure database connection with flexible options. \n\tRequired: host, port, database \n\tOptional: Any additional connection parameters via **kwargs \"\"\" \n\tbase_config = { 'host': host, 'port': port, 'database': database } # Merge with optional parameters \n\tfull_config = {**base_config, **connection_options} # Validate and set defaults for common options \n\tfull_config.setdefault('timeout', 30) \n\tfull_config.setdefault('pool_size', 10) return full_config\n```\n\n### Key Insights for *args and **kwargs\n\n- Use `*args` when you need to accept variable positional arguments\n- Use `**kwargs` for flexible keyword arguments and configuration\n- They enable clean API design and argument forwarding\n- Order matters: `def func(regular, *args, **kwargs)` is the standard pattern\n- Use `*` and `**` for unpacking when calling functions",
      "type": "text",
      "width": 785,
      "x": -535,
      "y": 4441
    },
    {
      "height": 1819,
      "id": "03ffbf7bfd944bfb",
      "styleAttributes": {
      },
      "text": "### HTTP\n\n**HTTP** – текстовый протокол, работающий поверх TCP/IP. HTTP состоит из запроса и ответа. Их структуры похожи: стартовая строка, заголовки, тело ответа.\nСтартовая строка запроса состоит из метода, пути и версии протокола: `GET /index.html HTTP/1.1\n`",
      "type": "text",
      "width": 1367,
      "x": 1591,
      "y": 9238
    },
    {
      "height": 2085,
      "id": "8b72e950776a8100",
      "styleAttributes": {
      },
      "text": "### Веб\n\n- **CGI (Common Gateway Interface), плюсы, минусы**\nСоглашение о том, как веб-сервер взаимодействует с программой, написанной на каком-то языке. Сервер запускает программу как исполняемый файл. Метод, путь, заголовки и тд.д. передаются через переменные окружения. \nПрограмма должна прочитать переменные и записать в стандартный поток вывода HTTP-ответ\nПлюсы: нет условий на язык, просто, программа не хранит состояние (удобно для отладки). Минусы: запуск процесса ос на каждый запрос отрабатывает очень медленно, передача данных через stdout медленней юникс-сокетов\n\n- **Защиты куки от воровства и подделки**\nЗависит от строгости критериев безопасности. Если хранятся вспомогательные данные, правилами можно пренебречь.\nДля платёжных систем, сайтов с привватными данными правила обязательны.\n\t- Выставлять кукам флаг httponly. Браузер на даст прочесть и изменить такие куки на клиенте js\n\t- Использовать флаг secure. Куки будут переданы только по безопасному соединению\n\t- Устанавливать короткий срок жизни\n\t- Устанавливать короткий срок сессии на сервере\n\t- Добалвять в кключ сессии заголовок User-Agent. Тогда ключ сессии на другой машине будет другим\n\t- Аналогично п. выше, но добавлять IP пользователя. \n\t- Подписывать секретным ключом. Добавлять `sig`, которое равно `HMAC-SHA1(cookie-body, secret_key`. На сервере проверять, что подпись совпадает\n\n- **Разница между аутентификацией и авторизацией**\n**Идентификация**: писвоение субъектам и объектам идентификатора и/или сравнение идентификатора с перечнем присвоенных идентификаторов. Например, представление человека по ИО.\n**Аутентификация** - проверка соответствия субъекта и того, за коо он пытается себя выдать с помощью уникальной информации; в простейшем случае с помощью логина и пароля. \n**Авторизация** - проверка и определение полномочий на выполнение определённых действий в соответствии с ранее выполненной аутентификацией.\nОпределение логина - идентификаций, проверка пароля - аутентификация, предоставление доступа - авторизация\n\n- **XSS** - межсайтовые запросы. Подверженная уязвимости страница вынуждает пользователя выполнить запрос к другой странице, либо запустить нежелательный js-код. Например, комментарий с кодом `html<script>alert('foo');</script>`. Движок сайта не фильтрует текст комментария, поэтому тег становится частью страницы и исполняется браузером. Другой пример. Страница поиска принимает поисковой терм `q`. В заголовке фраза \"Результат поиска по запросу\" + текст параметра. Если не экранировать запрос, то `/search?q=<script>alert('foo');</script>` приведёт к аналогичному результату. \nУязвимость устраняется экранированием небезопасных символов, чисткой (санацией) HTML-тегов.\n\n- **REST & SOAP**\nREST (Representational state transfer \"передача состояния представления\") - соглашение о том, как выстраивать сервисы. Часто имеют в виду HTTP REST API. Как правило, это веб-приложение с набором URL - endpoints. URL принимают и возвращают данные в JSON. Тип задаётся методом HTTP-запроса: GET, POST, PUT, PATCH, DELETE, HEAD. REST-архитектура использует возможности HTTP, чтобы избежать т.н. \"велосипедов\" - собственных решений. Параметры кеширования передааются стандартными заголовками `Cache`, `If-Modified-Since`, `ETag`. Авторизация - заголовком `Authentication`.\nREST - архитектурный стиль для проектирования слабо связанных HTTP приложений, часто используется при разработке веб-сервисов. REST не диктует правил low-level имплементации, он даёт высокоуровневые гайдлайны и оставляет свободу имплементации.\nДля веб-служб, построенных с учётом REST, применяют термин RESTful.\nВ отличие от сервисов на основе SOAP, не существует официальног остандарта для RESTful веб-API. REST - архитектурный стиль, SOAP - протокол.\n6 архитектурных ограничений:\n1. Единообразие интерфейса\n2. Клиент-сервер\n3. Отсутствие состояния\n4. Кэширование\n5. Слои\n6. Код по требованию (необязательное ограничение)\n\n**Единообразие интерфейса** Вы должны придумать API интерфейс для ресурсов системы, доступный для пользователей системы и следовать ему во что бы то ни стало. Ресурс в системе должен иметь только один логичный URI, который должен обеспечивать способ получения связанных или дополнительных данных. Всегда лучше ассоциировать (синонимизировать) ресурс с веб страницей.\n**Клиент-сервер** По сути, это означает, что клиентское приложение и серверное приложение ДОЛЖНЫ иметь возможность развиваться по отдельности без какой-либо зависимости друг от друга. Клиент должен знать только URI ресурса и больше ничего. Сегодня это нормальная практика в веб-разработке, поэтому с вашей стороны ничего особенного не требуется. Будь проще.\n**Отсутствие состояния** Рой Филдинг черпал вдохновение из HTTP, и это отражается в этом ограничении. Сделайте все клиент-серверное взаимодействие без состояний. Сервер не будет хранить информацию о последних HTTP-запросах клиента. Он будет рассматривать каждый запрос как новый. Нет сессии, нет истории.\n**Кэширование** В современном мире кэширование данных и ответов имеет первостепенное значение везде, где это применимо/возможно. Кэширование повышает производительность на стороне клиента и расширяет возможности масштабирования для сервера, поскольку нагрузка уменьшается.\n**Слои** REST позволяет вам использовать многоуровневую архитектуру системы, в которой вы развертываете API-интерфейсы на сервере A, храните данные на сервере B, a запросы аутентифицируете, например, на сервере C. Клиент обычно не может сказать, подключен ли он напрямую к конечному серверу или к посреднику.\n**Код по требованию (необязательное ограничение)** Это опциональное ограничение. Большую часть времени вы будете отправлять статические представления ресурсов в форме XML или JSON. Но когда вам нужно, вы можете вернуть исполняемый код для поддержки части вашего приложения, например, клиенты могут вызывать ваш API для получения кода визуализации виджета интерфейса пользователя. Это разрешено\n\n- **SOAP**\nSOAP (от англ. Simple Object Access Protocol - простой протокол доступа к объектам; вплоть до спецификации 1.2) - протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур. Официальная спецификация последней версии 1.2 протокола никак не расшифровывает название SOAP. SOAP является расширением протокола XML-RPC. SOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS и др. Однако его взаимодействие с каждым из этих протоколов имеет свои особенности, которые должны быть определены отдельно. Чаще всего SOAP используется поверх HTTP.\n\n- **Разница между REST и SOAP**\nREST поддерживает различные форматы: text, JSON, XML; SOAP - только XML,\nREST работает только по HTTP(S), а SOAP может работать с различными протоколами,\nREST может работать с ресурсами. Каждый URL это представление какого-либо ресурса. SOAP работает с операциями, которые реализуют какую-либо бизнес логику с помощью нескольких интерфейсов,\nSOAP на основе чтения не может быть помещена в кэш, а REST в этом случае может быть закэширован,\nSOAP поддерживает SSL и WS-security, в то время как REST - только SSL, SOAP поддерживает ACID (Atomicity, Consistency, Isolation, Durability). REST поддерживает транзакции, но не один из ACID не совместим с двух фазовым коммитом.\n\n- REST против SOAP можно перефразировать как \"Простота против Стандарта\". В случае REST (простота) у вас будет скорость, расширяемость и поддержка многих форматов. В случае с SOAP у вас будет больше возможностей по безопасности (WS-security) и транзакционная безопасность (ACID).",
      "type": "text",
      "width": 1383,
      "x": 159,
      "y": 9238
    },
    {
      "height": 874,
      "id": "3652f5431161b3ed",
      "styleAttributes": {
      },
      "text": "### Closures\nA closure occurs when a nested function captures and \"closes over\" variables from its enclosing scope. The inner function retains access to these variables even after the outer function has finished executing.\n```python\ndef create_multiplier(factor):\n    \"\"\"Create a function that multiplies by a specific factor.\"\"\"\n    \n    def multiply(number):\n        # This inner function has access to 'factor' from the outer scope\n        return number * factor\n    \n    # Return the inner function (this creates a closure)\n    return multiply\n\n# Create specific multiplier functions\ndouble = create_multiplier(2)\ntriple = create_multiplier(3)\n\nprint(double(5))  # 10 - the closure remembers factor=2\nprint(triple(4))  # 12 - this closure remembers factor=3\n```\n\n**State Encapsulation**, **Configuration and Factory Functions**\n\n`nonlocal` to modify variables from outer scope\n\n### Key Insights for Closures and Nonlocal\n\n- Closures capture variables from their enclosing scope\n- Use `nonlocal` to modify (not just read) variables from outer scope\n- Closures enable powerful patterns like state encapsulation and factory functions\n- Each closure maintains its own copy of the captured variables\n- Closures are memory-efficient alternatives to classes for simple state management",
      "type": "text",
      "width": 785,
      "x": 303,
      "y": 4441
    },
    {
      "height": 1590,
      "id": "72192f078d9dc614",
      "styleAttributes": {
      },
      "text": "### Strings\n\n```python\ns = \"abc\"\n```\n\nРегистр: `capitalize`,  `casefold`, **`lower`**,  **`upper`**,  **`swapcase`**, `title`, `istitle`,  **`islower`, `isupper`**\nПоиск/проверка содержимого: **`find`, `rfind`, `index`, `rindex`, `startswith`, `endswith`, `count`**\nПроверка свойств: **`isalnum`, `isalpha`**, `isascii`, `isdecimal`, **`isdigit`**, `isidentifier`, **`isnumeric`**, `isprintable`, **`isspace`**\nВыравнивание и заполнение: `center`, `ljust`, `rjust`, `zfill`\nУдаление и обрезка: **`strip`**, `lstrip`, `rstrip`, **`removeprefix`, `removesuffix`**\nРазделение и объединение: **`split`**, `rsplit`, `splitlines`, `partition`, `rpartition`, `join`\nЗамена и форматирование: **`replace`, `format`**, `format_map`, **`translate`, `maketrans`**\nПреобразование: `encode`, `expandtabs`\n\n```python\ntable = str.maketrans(\"abc\", \"123\")\ns = \"a brown cat\"\nprint(s.translate(table))  # → \"1 brown 1t\"\n```\n#### F-strings\n```python\nprint(f\"Item: ${price:>8.2f}\")  # Right-align with 8 total width, 2 decimal places\nprint(f\"Qty:  {quantity:>8d}\")   # Right-align integer with 8 total width\nprint(f\"Total: ${total:>7.2f}\")  # Creates a nicely aligned receipt format\nprint(f\"Test: .{18.3441:^10.3f}.\")\n```\n\n#### Regular expressions\n```python\npattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n```\n🔹 1. `^`\n- **Начало строки** — утверждает, что проверка идёт с начала строки.\n\n🔹 2. `[a-zA-Z0-9._%+-]+`\n- Это **имя пользователя** (часть email до `@`).  \n- `[a-zA-Z0-9._%+-]` — один символ из перечисленных:\n    \n    - `a-z`, `A-Z`: латинские буквы;\n        \n    - `0-9`: цифры;\n        \n    - `._%+-`: разрешённые спецсимволы.\n        \n- `+` — один или более таких символов.\n    \nПримеры допустимых:\n- `john.doe`, `user_123`, `alice+test`\n\n🔹 3. `@`\n- Просто символ `@` — разделяет имя пользователя и домен.\n\n🔹 4. `[a-zA-Z0-9.-]+`\n- Это **доменное имя**, часть после `@`.\n- Символы:\n    \n    - Буквы, цифры, точки (`.`), дефисы (`-`)\n        \n- `+` — один или более таких символов.\nПримеры:\n- `gmail.com`, `my-site.org`, `mail.server.co.uk`\n\n🔹 5. `\\.[a-zA-Z]{2,}`\n- `\\.` — буквально точка (не как любой символ!).\n- `[a-zA-Z]{2,}` — **расширение домена**, минимум из 2 букв (например, `.com`, `.org`, `.ru`, `.xyz`)\n\n🔹 6. `$`\n- **Конец строки** — утверждает, что строка должна закончиться после домена.\n#### String Interning\nOptimization technique where identical string objects share the same memory location\n- . - matches any single character except newline\n- ^ - matches the start of a string\n- $ - matches the end of a string\n- * - matches zero or more of the preceding character\n- + - matches one or more of the preceding character\n- ? - matches zero or one of the preceding character\n- \\ - escapes special characters",
      "type": "text",
      "width": 943,
      "x": 1467,
      "y": 4427
    },
    {
      "height": 1567,
      "id": "3d5bca13a034e633",
      "styleAttributes": {
      },
      "text": "### ООП\n\n🔍 `self` — ссылка на текущий экземпляр объекта. Через `self` мы получаем доступ к его атрибутам и методам.\n\n**Атрибуты экземпляра и методы**\n\n Атрибуты экземпляра\n\n- Уникальны для каждого объекта.\n    \n- Задаются обычно в `__init__`.\n    \n- Хранят состояние объекта.\n    \nМетоды экземпляра\n\n- Обычные функции внутри класса, принимают первым аргументом `self`.\n\n**Уровни доступа к атрибутам**\n\n|Префикс|Уровень доступа|Поведение|\n|---|---|---|\n|`self.attr`|Публичный|Доступен везде|\n|`self._attr`|Защищённый (protected)|По соглашению: \"не трогай извне\"|\n|`self.__attr`|Приватный (private)|Имя искажается → `_ClassName__attr`|\n\n **Геттеры и сеттеры (доступ к приватным полям)**\n ```python\n class User:\n    def __init__(self, name):\n        self.__name = name\n\n    def get_name(self):\n        return self.__name\n\n    def set_name(self, name):\n        if name:\n            self.__name = name\n\n```\nС использованием `@property` — _питоничный способ_:\n```python\nclass User:\n    def __init__(self, name):\n        self._name = name\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, new_name):\n        if new_name:\n            self._name = new_name\n\n```\n\n|Что?|Зачем?|\n|---|---|\n|`@property`|Делает функцию \"выглядящей как атрибут\"|\n|Геттер|Контролирует чтение значения|\n|Сеттер|Контролирует установку (валидация, логика, побочные эффекты)|\n|Ручной `get_name()`|Работает, но не питонично, требует явного вызова|\n|Прямой доступ `u.name`|Простой, но не даёт контроля|",
      "type": "text",
      "width": 1201,
      "x": 3154,
      "y": 9238
    },
    {
      "height": 618,
      "id": "3d8750d68e3faf75",
      "styleAttributes": {
      },
      "text": "**Публичые, защищённые и приватные атрибуты/методы**\n`var`, `_var`, `__var`\n\n**Геттеры, сеттеры**\n@property\n```python\ndef email(self):\n\tprint(\"Email accessed\")\n\treturn self._email\n```\n\n@email.setter\n```python\ndef email(self, new_email):\n\tif \"@\" in new_email:\n\t\tself._email = new_email\n```\n**Различные методы**\n просто метод без self - не будет вызываться от объекта\n@staticmethod - метод без self, когда нужно обращаться от объекта и класса\n@classmethod - метод с cls в качестве первого аргумента, использует класс\n@abstractmethod - не реализованный метод для абстрактного класса\n\\* abc - стандартный модель: Abstract Base Classes. Позволяет создавать абстрактные классы",
      "type": "text",
      "width": 1039,
      "x": 3154,
      "y": 10862
    },
    {
      "height": 638,
      "id": "8c900b72d27d78f3",
      "styleAttributes": {
      },
      "text": "### Индексы\n**Индексы** в базах данных — это структуры данных, которые **улучшают скорость выполнения операций извлечения данных (чтения)** из таблицы, за счет того, что они обеспечивают быстрый доступ к строкам по значениям в одном или нескольких столбцах. Представьте их как **предметный указатель в книге**.\n\n### Как это работает?\n\n- Индекс создается на одном или нескольких столбцах таблицы.\n- При создании индекса, база данных создает отдельную структуру данных (часто B-дерево), которая хранит отсортированные значения индексированных столбцов вместе со ссылками на соответствующие строки в основной таблице.\n- Когда вы выполняете запрос `SELECT` с условием `WHERE` по индексированному столбцу, СУБД сначала ищет данные в индексе, находит нужные ссылки на строки и затем напрямую переходит к этим строкам в основной таблице, что гораздо быстрее, чем последовательный просмотр всей таблицы (полное сканирование таблицы\n\n\\+: SELECT, ORDER BY, JOIN, уникальность\n\\-: запись, память, не всегда полезны",
      "type": "text",
      "width": 688,
      "x": -57,
      "y": 16771
    },
    {
      "height": 389,
      "id": "c9baeb40d3630285",
      "styleAttributes": {
      },
      "text": "### ACID\nТранзакция - логическая единица работы, состоящая из 1+ операцй над данными. Либо полностью завершена, либо rollback \n\nACID - 4 свойства, которыми должна обладать субд для обеспечения надёжности обработки данных\n\nA - atomicity (атомарность)\nC - consistency (согласованность). Переводит бд из одного согласованного состояния в другое\nI - изолированность. Параллельно выполняемые транзакции изолированы друг от друга\nD - durability. Надёжность/устойчивость - после завершения транзакции её изменения становятся постоянными и сохраняются в базе данных",
      "type": "text",
      "width": 704,
      "x": -1711,
      "y": 16422
    },
    {
      "height": 508,
      "id": "9c192e69c54788fd",
      "styleAttributes": {
      },
      "text": "### Материализованное представление (MATERIALIZED VIEW)\n\n- **Что это:** **Физическая таблица**, которая хранит **результат SQL-запроса**. В отличие от обычного VIEW, данные в Materialized View **сохраняются на диске** и периодически **обновляются** (материализуются) из базовых таблиц.\n- **Назначение:** - - **Повышение производительности чтения:** Поскольку данные предварительно вычислены и хранятся, запросы к Materialized View выполняются гораздо быстрее, чем к обычному VIEW (или прямо к базовым таблицам с JOIN-ами).\n    - **Для аналитики (OLAP):** Идеально подходит для агрегированных данных, сложных отчетов и дашбордов, где требуется быстрый доступ к итогам, но данные не меняются в реальном времени.\n    - **Кэширование:** Действует как форма кэша.",
      "type": "text",
      "width": 582,
      "x": -685,
      "y": 16771
    },
    {
      "height": 452,
      "id": "2fc265eef44fa66b",
      "styleAttributes": {
      },
      "text": "### Представление (VIEW)\n\n- **Что это:** **Виртуальная таблица**, которая не хранит данные самостоятельно. Она представляет собой **сохраненный SQL-запрос**. При обращении к представлению, база данных выполняет этот запрос и возвращает результат.\n- **Назначение:**\n    - **Упрощение сложных запросов:** Сложный запрос с JOIN-ами и фильтрами можно сохранить как VIEW, и затем просто `SELECT * FROM MyView`.\n    - **Безопасность:** Можно ограничить доступ пользователей к определенным столбцам или строкам базовых таблиц, предоставляя им доступ только к VIEW.\n    - **Согласованность данных:** Представляет собой всегда актуальное состояние данных, так как каждый раз заново вычисляется.\n    - **Абстракция данных:** Скрывает реальную структуру базовых таблиц.\n- **Пример:** `CREATE VIEW ActiveCustomers AS SELECT CustomerID, Name, Email FROM Customers WHERE Status = 'Active';`",
      "type": "text",
      "width": 973,
      "x": -1711,
      "y": 16827
    },
    {
      "height": 1518,
      "id": "fecf2035e521b95b",
      "styleAttributes": {
      },
      "text": "### Взаимодействие с веб-сайтом\n**Шаг 1. Ввод URL и его анализ браузером**\n1\\. Вводим URL, нажимаем enter\n`https://www.example.com/products/item123?color=red#overview`\n- URL - уникальный указатель (locator) ресурса. Полный адрес ресурса в интернете, который указывает на местоположение и способ доступа к нему\n- URI - уникальный идентификатор ресурса. Более общее, чем URL\n- Компоненты URL:\n\t- `https://`: Схема/протокол\n\t- `www.example.com`: хост/доменное имя\n\t- `/products/item123`: конкретный путь к ресурсу на сервере\n\t- `?color=red`: строка запроса (query string)\n\t- `#overview`: фрагмент/якорь - указывает определенный раздел внутри самого ресурса\n2\\. Проверка кэша браузера:\n- Кэш хранит ранее загруженные изображения, CSS, JavaScript\n- DNS-кэш\n\n**Шаг 2. Разрешение доменного имени (DNS-запрос)**\nIP-адрес не найден в кэше браузера, начинается процесс DNS-разрешения:\n- Локальный DNS-кэш ОС\n- Запрос к hosts\n- Запрос к DNS-серверу\n- Рекурсивный запрос DNS\n\n**Шаг 3. Установление TCP-соединения**\nБраузер знает IP-адрес сервера, нужно установить соединение:\n1\\. SYN-пакет (Synchronize) - отправляет SYN-пакет на 80 | 443\n\t- TCP устанавливает соединение перед передачей данных\n2\\. Обратно SYN-ACK пакет\n3\\. ACK-пакет от браузера\n\\* Three-way Handshake\n\n**Шаг 4. TLS/SSL соединение (для HTTPS)** \nTLS/SSL-Handshake: обмен сообщениями, чтобы:\n- Согласовать протокол шифрования (+ хэшироание)\n- Обмен ключами (ассиметричное шифрование e.g. RSA)\n- Аутентификация сервера (браузер проверяет SSL/TLS-сертификат)\n- Шифрование данных\n\n**Шаг 5. HTTP-запрос**\n\n**Шаг 6. Обработка запроса на сервере**\n- Приём запроса\n- Обработка статики/динамики\n- Обработка запроса приложением\n- Генерация HTTP-ответа (HTML, JSON, XML)\n\n**Шаг 7. HTTP-ответ**\n\n**Шаг 8.** Рендеринг страницы браузером, завершение и интерактивность\n",
      "type": "text",
      "width": 913,
      "x": 977,
      "y": 17572
    },
    {
      "height": 819,
      "id": "1b996ed103a77f87",
      "styleAttributes": {
      },
      "text": "### Клиент, сервер; веб-сервер\n\n**Клиент** - по/устройство которое делает запросы к другому по/устройству\n- Браузеры (веб-страницы), почтовые клиенты, мобильные приложения, терминалы (ssh-клиент, подключение к удалённому серверу)\n\n**Сервер** - по/устройство, предоставляющее ресурсы/услуги по запросу клиента через сеть\n- Веб-серверы (Apache, Nginx, IIS) (отдают веб-страницы), почтовые серверы (хранят и отправляют письма), сервера бд (MySQL, etc.; ханят и предоставляют данные) , файловые сервера, игровые, etc. \n\n**Веб-сервер** - специализируется на HTTP-запросах. \nПринцип:\n- Слушает порт (80 HTTP, 443 для HTTPS) на наличие входящих HTTP-запросов\n- Когда браузер вводит URL, отправляет запрос на IP-сервер, связанный с этим доменом\n- Обработка запроса: веб-сервер получает запрос и определяет запрашиваемый ресурс (статческий контент (e.g. html на диске сервера), динамический (e.g. результат поиска/данные из бд; управление передаётся другому по, потом результат генерируется и передаётся серверу)\n- После того как веб-сервер получил контент, упаковывает его в http-ответ и отправляет обратно браузеру клиента\n- Браузер отображат ответ пользователю\nПосредник, доставка контента, эффективность",
      "type": "text",
      "width": 624,
      "x": -2270,
      "y": 17572
    },
    {
      "height": 1516,
      "id": "70410bcec6f02ab3",
      "styleAttributes": {
      },
      "text": "### API (Application Programming Interface) \n\n**API** - набор правил, протоколов и инструментов для создания ПО, который позволяет разным приложениям взаимодействовать друг с другом и обмениваться данными.\nAPI - посредник, который позволяет одной программе поговорить с другой\n\nИдеи:\n1. Набор праил:\n\t - Методы (операции)\n\t - Форматы данных\n\t - Точки доступа (эндпойнты)\n\t - Аутентификация/Авторизация\n2. Абстракция (сокрытие сложности)\n3. Модульность и переиспользование\n\n**Web API** - зонтичный термин, который относится к любому API, доступ к которому осуществляется по HTTP/HTTPS\nХарактеристики:\n- Протокол HTTP/HTTPS\n- Доступность через URL\n- Формыты данных: JSON (javascript object notation), XML (extensible markup language)\n- Используются веб-браузерами и другими приложениями\nПример: погодные приложения\n\n\\* REST API, SOAP API - Web API, но не наоборот\n\n**REST** (от англ. Representational State Transfer — «передача репрезентативного состояния» или «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.\n**Архитектурный стиль для проектирования распределённых систем**\n\n**REST (Representational State Transfer) API** - архитектурный стиль для создания Web API.\nОсновные принципы REST (RESTful constraints):\n1. Клиент-сервер (разделение обязанностей: клиент не заботится о хранении данных, сервер об отображении пользовательского интерфейса)\n2. Отсутствие состояние (Stateless) - каждый запрос от клиента серверу должен содержать всю необходимую информацию для обработки запроса, сервер не хранит информацию о предыдущих запросах. Упрощает масштабирование\n3. Кэшируемость (Cacheable) - ответы должны помечены как кэшируемые/нет. Улучшает производительность (клиенты и промежуточные серверы кэшируют ответы)\n4. Единообразный интерфейс (Unifor Interface) - самый важный принцип REST:\n\t- Ресурсы идентифицируются с помощью URL-адресов\n\t- Манипуляция ресурсами через представления (клиент изменяет ресус, отправляя его представление)\n\t- Самоописывающие сообщение (каждое сообщение должно содержать достаточно информации для обработки)\n5. Многослойная система (клиент не должен знать, общается ли с конечным сервером или промежуточным)\n6. Код по требованию (необязательно)\n\nЮзкейсы: мобильные и веб-приложения, публичные апи. ресурсы с небольшой изменчивостью\n\n**SOAP** - строгий протокол на XML",
      "type": "text",
      "width": 847,
      "x": -1605,
      "y": 17572
    },
    {
      "height": 649,
      "id": "5765151c368c65b2",
      "styleAttributes": {
      },
      "text": "### HTTP \nПротокол прикладного уровня для передачи данных в распределённых гипермедийных информационных системах.\n- Протокол запрос/ответ\n- Stateless (сервер не помнит состояние клиента между запросами)\n- Соединение без сохранения состояния (?)\n- Медиа-независимость (любой контент при согласии сторон)\n- Расширяемость\n\nЗапрос:\n- Стартовая строка:\n\t- Запрос: `Метод URI Версия_HTTP`: `GET /index.html HTTP/1.1`\n\t- Ответ: `Версия_HTTP Код_состояния Сообщение_состояния`: `HTTP/1.1 200 OK`\n- Заголовки: пара ключ-значение, предоставляющие метаданные о сообщении \n(`Content-Type`, `User-Agent`, `Accept`, `Authorization`)\n- Пустая строка\n- Тело сообщения (необязательная часть, содержащая фактические данные)\n\nHTTP/1.1, HTTP/2 (на основе SPDY, бинарный), HTTP/3 (QUIC поверх UDP)\n\nМетоды: \nGET, POST, PUT, PATCH, DELETE; HEAD, OPTIONS, CONNECT, TRACE",
      "type": "text",
      "width": 819,
      "x": -713,
      "y": 17572
    },
    {
      "height": 886,
      "id": "448c17cc40410d8e",
      "styleAttributes": {
      },
      "text": "### IP, TCP/IP\n**IP (Internet Protocol)** - протокол **сетевого уровня** (согласно модели TCP/IP или уровень 3 в OSI), который отвечает за логическую адресацию и маршрутизацию пакетов данных от отправителя к получателю через множество взаимосвязанных сетей.\n\nФункции:\n1. Адресация (Adressing):\n\t - Уникальный адрес для каждого устройства в сети\n\t - IP-адрес - уникальный идентификатор\n\t - Две версии: IPv4 (32 бит, 4 десятичных числа 172.217.160.142), IPv6 (128 бит в 16-ричном формате, разделённом двоеточиями 2001:0db8:85a3:0000:0000:8a2e:0370:7334)\n\t - IP-адрес позволяет роутерам знать, куда отправить пакет данных, чтобы он достиг нужного устройства\n 2. Маршрутизация (Routing):\n\t- IP определяет, как пакеты данных должны перемещаться между различными сетями\n\t- Пересылка от одной сети к другой, пока пакет не достигнет цели\n 3. Без установления соединения (Connectionless) - просто отправляет пакеты данных по сети, не гарантирует доставку, порядок, отсутствие дубликатов\n 4. Ненадёжный\n\n**TCP/IP** - стек сетевых протоколов, который составляет основу Интернета и большинства сетей. Модель, альтернативная TCP/IP\n\n**1\\. Уровень сетевого доступа (Network Access Layer)**\n(1-2 OSI: Physical, Data Link). Ethernet, Wi-Fi\n**2\\. Интернет-уровень (Internet Layer)**\n3 уровень OSI. **Здесь работает IP**\n**3\\. Транспортный уровень (Transport Layer)**\n4 уровень OSI. Сквозная часть между прилоениями на разных хостах. TCP, UDP\n**4\\. Прикладной уровень**\nСоответствует 5-7 OSI. Предоставляет сетевые службы для конечных приложений\nHTTP/HTTPS, FTP, SMTP, DNS, SSH, Telnet",
      "type": "text",
      "width": 806,
      "x": 132,
      "y": 17572
    },
    {
      "height": 252,
      "id": "bf6452d16d4f9ffc",
      "styleAttributes": {
      },
      "text": "### DNS\nСистема доменных имён, которая работает как телефонная книга интернета\nПреобразует доменные имена (google.com) в IP-адреса, используемые устройствами для идентификации друг друга в сети\n**Принцип работы:** вводим доменное имя в браузере, он запрашивает DNS-сервер, который находит IP-адрес и возвращает его. Браузер затем может установить соединение с сервером по IP",
      "type": "text",
      "width": 806,
      "x": 132,
      "y": 18478
    },
    {
      "height": 203,
      "id": "3ec6049016ba425d",
      "styleAttributes": {
      },
      "text": "### Маска подсети\n32-битное (для IPv4) число, которое определяет, какая часть IP-адреса относится к адресу сети, а какая к адресу хоста\nПрименяется к IP-адресу с помощью логической операции \"И\" (`AND`). Биты маски, установленные в `1`, соответствуют сетевой части, а биты, установленные в `0`, — хостовой части.\n",
      "type": "text",
      "width": 806,
      "x": 132,
      "y": 18751
    },
    {
      "height": 1045,
      "id": "8a219ccad4521838",
      "styleAttributes": {
      },
      "text": "### ASGI и UWSGI\n\n**ASGI (Asynchrous Server Gateway Interface)** - стандарт (спецификация), который определяет, как веб-серверы должны взаимодействовать с Python-веб-приложениями, способными работать асинхронно. Наследник WSGI (Web ...)\n\nОсобенности и зачем нужен:\n- Асинхронность: повзоляет python-приложениям эффективно обрабатывать множество запросов, не блокируя выполнение\n- Поддержка различных протоколов:\n\t1) HTTP/1.1, HTTP/2 (стандартные запросы)\n\t2) WebSockets (чаты, игры)\n\t3) Server-Sent events (SSE)\n- Модель взаимодействия:  Приложение ASGI - вызываемый объект (асинк функция/класс, три аргумента: `scope`, `receive`, `send` \n\t1) scope - словарь, содержащий информацию о текущем соединении (протокол, заголовки, HTTP, путь)\n\t2) receive - асинк вызываемая функция, которая позволяет приложению получать события от клиента\n\t3) send - асинк функция, которая позволяет приложению отправлять события клиенту (http-ответы, сообщения websocket)\nАналогия: WSGI - один звонок на телефонную линию, ASGI - колл-центр\n\n**uWSGI** - веб-сервер приложений и протокол. Изначально создан для запуска приложений с WSGI, но расширил поддержку и может работать с приложениями на других языках и протоколами.\n\nОсобенности и зачем нужен:\n- Мост между внешним веб-сервером (Nginx, Apache) и приложением. Принмает запросы от Nginx, передаёт приложению, получает ответ от приложения и отправляет обратно Nginx\n- Управление процессами/потокаи (несколько рабочих процессов для параллельной обработки запросов)\n- Балансировка нагрузки\n- Кэширование \n- Логгирование\nНе является нативным ASGI-сервером в том смысле, как Uvicorn",
      "type": "text",
      "width": 624,
      "x": -2270,
      "y": 18429
    },
    {
      "height": 392,
      "id": "fd90f94f804e9a7e",
      "styleAttributes": {
      },
      "text": "### Способы авторизации\nАвторизация: \"что разрешено делать\"\n- Role-Based Access Control (пользователям назначаются роли), для каждой роли определён набор разрешений\n- На основе атрибутов (Attrubute-Based Access Control) - на основе атрибутов пользователя, ресурса, окружающей среды, действия. Правила могут быть очень детализированными\n- На основе списков контроля доступа \n- OAuth 2.0 (Делегированная авторизация). Протокол позволяет пользователю предоставить стороннему приложению ограниченный доступ к своим ресурсам на другом сервере без передачи пароля\n- Token-Based Authorization (включая JWT): после аутентификации выдаётся токен, используется для подтверждения личности и прав каждый раз",
      "type": "text",
      "width": 806,
      "x": 132,
      "y": 18974
    },
    {
      "height": 1638,
      "id": "74da074b443865d6",
      "styleAttributes": {
      },
      "text": "### Nginx\n\nNginx - мощный высокопроизводительный, легковесный и open source веб-сервер, обратный прокси-сервер, почтовый прокси и универсальный tcp/udp прокси сервер. Изначально для решения проблемы C10k - обработки большого количества соединений\n\nЭффективная обработка большого количества подключений. Асинхронная архитектура\n\nВозможности:\n1\\. Веб-сервер (HTTP-сервер):\n- Статический контент (раздача HTML, CSS, JS, ...)\n- Виртуальные хосты: позволяет разщмещать несколько сайтов на одном сервере, каждый со своим доменным именем\n- SSL/TLS шифрование: поддерживает HTTPS\n- Gzip сжатие\n- Кэширование\n\n2\\. Обратный прокси:\n- Перенаправление запросов (запрос от клиента -> один/несколько бэкенд серверов)\n- Сокрытие архитектуры\n- Единая точка входа\n\n3\\. Балансировщик нагрузки (Load Balancer):\n- Распределение трафика\n- Алгоритмы балансировки\n- Health checks \n...\n\nЮзкейсы:\n\n1\\. Хостинг high-load \n- Сценарий: Интернет-магазин c 10kk+ rpd\n- Решение: Nginx для быстрой отдачи статического контента и как обратный прокси для перенаправления динамических запросов (корзина, оформление заказа) на несколько бэкенд-серверов. Балансировка нагрузки между серверами\n\n2\\. Микросервисная архитектура\n- Сценарий: Приложение - множество небольших, независимых сервисов\n- Решение: Nginx - API Gateway. Запросы сперва на Nginx, затем, в зависимости от URL или заголовков, машрутизирует запрос к соответствующему микросервису\n\n3\\. Кэширование контента для CDN:\n- Сценарий: контент, который часто запрашивается из разных геоточек\n- Решение: Nginx как кэширующий прокси-сервер в разных регионах. Кэширует статический контент от основного сервера.\n\n4\\. Управление доступом и безопасностью\n\n5\\. Разработка и развёртывание",
      "type": "text",
      "width": 603,
      "x": -2900,
      "y": 17572
    },
    {
      "height": 586,
      "id": "bb6cd9bcd0388b3b",
      "styleAttributes": {
      },
      "text": "### Типы БД\n\n1\\. Реляционные (RDBMS)\n- Основа - **реляционная модель данных**, где данные хранятся в **таблицах**, состоящих из строк и столбцов. Таблицы связаны между собой через общие поля (ключи)\n- Связи: Primary keys, Foreign ke ys\n- Язык: SQL\n- Строгая схема, поддержка ACID-транзакций\n- Примеры: MySQL, PostreSQL, SQLite\n\n2\\. Нереляционные (NoSQL | Not Only SQL)\n- Для решения проблем масштабируемости, гибкости\n- Часто не имеют строгой фиксированной схемы\nТипы:\n- Key-Value stores (Redis)\n- Document Databases: Хранят данные в виде полуструктурированных документов (JSON, XML, BSON), которые могут быть вложенными и иметь гибкую структуру. (MongoDB, Couchbase)\n- Графовые Neo4j\n- Временные ряды: InfluxDB",
      "type": "text",
      "width": 704,
      "x": -1711,
      "y": 14893
    },
    {
      "height": 1105,
      "id": "3198da9baadfa460",
      "styleAttributes": {
      },
      "text": "### Нормализация\n\n**Нормализация** - систематический процесс организации данных в реляционной бд с целью:\n- уменьшить изыточность данных (дубликаты)\n- повышение целостности (гарантия согласованности и правильности)\n- улучшение эффективности хранения (снижение объема хранимых данных)\n- упрощение запросов и модификации данных \n\nПроцесс заключается в декомпозиции (разбиении) больших таблиц на более мелкие, а затем определении связей между ними\nАномалии:\n- Аномалия вставки (Insertion Anomaly). Невозможно добавить новые данные, если нет полной информации для всех полей.  Например, нельзя добавить информацию, пока нет поставщика (если данные хранятся в одной таблице) NULLABLE?\n- Аномалия обновления (Update Anomaly). Изменение одной и той же информации требует обновления нескольких строк, что может привести к несогласованности данных, если не все копии будут обновлены.\n- Аномалии удаления (Deletion Anomaly). Удаление одной записи может привести к потере важной информации о других сущностях. Например, удаляя последний товар поставщика можем удалить случайно всю информацию о поставщике\n\nНормальные формы\n0\\. UNF - исходное состояние\n\n1\\. 1NF:\n- Каждый столбец должен содежать атомарные значеня\n- Каждая строка должна быть уникальной (первичный ключ)\n- Каждый столбец должен иметь уникальное имя\n- Порядок строк и столбцов не имеет значения\n\n2\\. 2NF: \n- 1NF\n- Каждый неключевой атрибут должен полностью функционально зависеть от всего первичного ключа. Если пк состоит из нескольких атрибутов, то никакой из неключевых атрибутов не дожен зависеть полностью только от части ключа\nРешаемая проблема: частичная функциональная зависимость\n\n3\\. 3NF\n- 2NF\n- Не должно быть транзитивных функциональных зависимостей неключевых атрибутов\n\n4\\. Нормальная форма Бойса-Кодда (Boyce-Codd Normal Form - BCNF)\n- 3NF\n- Для каждой нетривиальной функциональной зависимости `X → Y`, `X` должен быть суперключом\n\nДенормализация - отказ от нормализации, для уменьшения количества таблиц (проблема: нужно много джойнов)\n",
      "type": "text",
      "width": 1121,
      "x": -955,
      "y": 14893
    },
    {
      "height": 264,
      "id": "350ba723a688e7ee",
      "styleAttributes": {
      },
      "text": "### Триггеры (Triggers)\n\n- **Что это:** Специальный тип хранимой процедуры, которая **автоматически выполняется** (срабатывает) в ответ на определенные события в базе данных.\n- **События-триггеры:** Чаще всего это операции DML (Data Manipulation Language): `INSERT`, `UPDATE`, `DELETE`. Триггеры могут срабатывать **до** (`BEFORE`) или **после** (`AFTER`) выполнения этих операций.\n- **Пример:** Триггер `AFTER INSERT` на таблице `Заказы` может автоматически уменьшать количество соответствующего товара на складе в таблице `Товары`.",
      "type": "text",
      "width": 1121,
      "x": -984,
      "y": 16014
    },
    {
      "height": 609,
      "id": "41bc6ef1e800b557",
      "styleAttributes": {
      },
      "text": "### Сокет\n\n**Сокет** - точка соединения между двумя программами по сети.\n- На практике это способ общения клиента и сервера по протоколам вроде TCP или UPD\n```python\n# Сервер\nimport socket\ns = socket.socket()\ns.bind(('localhost', 1234))\ns.listen()\nconn, addr = s.accept()\ndata = conn.recv(1024)\n\n# Клиент\nimport socket\ns = socket.socket()\ns.connect(('localhost', 1234))\ns.sendall(b'Hello')\n```\n\n- Сокеты работают на низком уровне - напрямую с IP/портами\n- Через сокеты строятся все остальные протоколы: HTTP, FTP и т.д.\n- Поддерживают двустороннее общение (двупоточное или асинхронное)\n\n",
      "type": "text",
      "width": 861,
      "x": -2699,
      "y": 15404
    },
    {
      "height": 841,
      "id": "8a46d68a8c7da754",
      "styleAttributes": {
      },
      "text": "### Прокси \n\n**Прокси (proxy)** - посредник между клиентом и целевым сервером.\n\nКлиент -> Прокси -> Сервер\nОтвет <- Прокси <- Сервер\n\nПрокси:\n- Скрывает IP-адрес\n- Кэширует ответы (ускоряет доступ)\n- Фильтрует трафик\n- Обходит блокировку\n- Балансирует нагрузку\n\nПримеры:\n- HTTP-прокси: работает с HTTP-запросами\n- SOCKS-прокси (TCP, UDP)\n\n---\n\n## 📊 Сравнение\n\n|Характеристика|Сокет|Прокси|\n|---|---|---|\n|Уровень|Низкий (транспортный)|Более высокий (сетевой/прилож.)|\n|Назначение|Прямое соединение|Посредничество|\n|Протоколы|TCP/UDP|HTTP, HTTPS, SOCKS|\n|Управляет соединением|Клиент напрямую|Прокси управляет|\n|Примеры использования|Сервер-чаты, игры, WebSocket|Анонимность, фильтрация, VPN|",
      "type": "text",
      "width": 861,
      "x": -2699,
      "y": 16048
    },
    {
      "height": 1297,
      "id": "abea5c8f1545c5ef",
      "styleAttributes": {
      },
      "text": "### OSI\n**OSI (Open System Interconnection)** - эталонная 7-уровневая модель. Цель - универсальный и абстрактный фреймворк для понимания и проектирования сетевых коммуникаций\n\n**All people seem to need data processing**\n\n7\\. **Application layer** - взаимодействие непосредственно с пользовательскими приложениями\nHTTP, FTP, SMTP, DNS, Telnet. Пользовательские данные\n6\\. **Presentation layer** - преобразование, форматирование, сжати и дешифрование днных, чтобы обеспечить своместимость между системами (преобразование кодировок, сжатие данных, шифрование)\nПротоколы (?): JPEG, MPEG, ASCII, TLS/SSL\nДанные: Отформатированные/зашифрованные\n5\\. **Session Layer** - управление сеансами между приложениями на разных устройства. Устанавливает, поддерживает и завершает диалоги между приложениями. RPC, Sockets. Данные: Сеансовые единицы данных\n4\\. **Transport layer** - отвечает за сквозную (end-to-end) доставку данных между приложениями на разных хостах. Надёжность, управление потоком и исправление ошибок\nTCP - надёжная доставка (правильный порядок, повторная передача потерянных пакетов, котроль ошибок\nUDP - ненадёжная доставка: бысто, но без гарантии доставки и порядка\n3\\. **Network layer** - логическая адресация и маршрутизация пакетов данных между различными сетями (межсетевое взаимодействие)\nЗадачи: логическая адресация (присвоение IP-адресов), маршрутизация (routing для наилучшего пути доставки), фрагментация/дефрагментация (разделение на более мелкие части, если требуется)\nПротоколы: IP (Internet Protocol), ICMP (Internet Control Message Protocol), OSPF\nДанные: пакеты\n2\\. **Data link layer** - передача данных по локальному каналу связи (между двумя напрямую соединёнными узлами). Отвечает зафизическую адресацию (MAC-адреса) и обнаружение/исправление ошибок \nПротоколы: Ethernet, Wi-Fi (IEEE 802.11), PPP, ATM\nДанные: кадры (Frames)\n1\\. **Physical Layer**\nФизическая передача битов данных по физической среде. Преобразование битов в электрические/оптические/радиосигналы. \nОборудование/стандарты: кабели, разъёмы, сетевые карты (NIC), Bluetooth, USB\nДанные: биты (Bits)\n\n- **7. Прикладной:** Вы пишете письмо (данные приложения).\n- **6. Представления:** Вы форматируете текст, возможно, используете какой-то секретный код (шифрование).\n- **5. Сеансовый:** Вы решаете, сколько писем отправить за раз, и как их группировать.\n- **4. Транспортный:** Вы кладете письмо в конверт, пишите свой адрес и адрес получателя (порт отправителя и получателя), чтобы быть уверенным, что оно дойдет и будет собрано правильно, если придется отправить несколько конвертов (сегменты).\n- **3. Сетевой:** Вы пишете на конверте почтовый адрес получателя и свой обратный адрес (IP-адреса). Почтовая служба решает, каким путем отправить письмо.\n- **2. Канальный:** Почтальон помещает письмо в сумку для доставки в соседний почтовый ящик или отделение (кадр), записывает номер своего маршрута (MAC-адрес).\n- **1. Физический:** Само письмо (электрический сигнал, световой импульс) физически перемещается по дороге, через сортировочные центры, по проводам или воздуху.",
      "type": "text",
      "width": 819,
      "x": -713,
      "y": 18245
    },
    {
      "height": 137,
      "id": "8b690188e40431e4",
      "styleAttributes": {
      },
      "text": "### JWT\nJWT (JSON Web Token) - компактный URL-безопасный и самодостаточный стандарт для создания токенов доступа, который используется для безопасной передачи информации между сторонами в виде объекта JSON",
      "type": "text",
      "width": 806,
      "x": 132,
      "y": 19405
    },
    {
      "height": 772,
      "id": "a3c55c03a3a51682",
      "styleAttributes": {
      },
      "text": "---\n\n|🧱 **Принцип REST**|✅ **Хороший пример**|❌ **Плохой пример**|\n|---|---|---|\n|**Используй HTTP-методы по назначению**|`@app.get(\"/users/{id}\")` — получить пользователя|`@app.post(\"/get-user\")` — чтение через POST|\n|**Ресурс в URL — сущность, не действие**|`/users` — список пользователей|`/getAllUsers` — глагол в пути|\n|**Используй глагол в методе, не в пути**|`@app.post(\"/users\")` — создание|`@app.post(\"/createUser\")` — дублирование смысла|\n|**Обновление ресурса = PUT/PATCH**|`@app.put(\"/users/{id}\")` — обновление|`@app.post(\"/users\")` — делает create _или_ update|\n|**Вложенные ресурсы через иерархию**|`/posts/{post_id}/comments` — комменты к посту|`/comments?post_id=...` — неясная связь|\n|**POST — для создания**|`@app.post(\"/articles\")` — создать статью|`@app.post(\"/articles/{id}\")` — нарушает смысл POST|\n|**Явные действия — отдельные endpoints**|`@app.post(\"/users/{id}/reset-password\")`|`@app.patch(\"/users\")` с телом `{\"action\": \"reset_password\"}`|\n|**Используй статус-коды корректно**|`return {\"msg\": \"ok\"}, 201` при создании|`return {\"msg\": \"created\"}, 200` — создаёт, но не сообщает об этом|\n|**Путь к ресурсу = имя ресурса**|`/orders/{id}`|`/get_order_by_id` — нарушает REST-стиль|\n|**Фильтрация — через query-параметры**|`/products?category=books`|`/products/by-category/books` — лишние уровни|\n|**PUT — идемпотентен, POST — нет**|`PUT /users/123` — можно вызывать повторно|`POST /users/123` — каждый вызов может дублировать|",
      "type": "text",
      "width": 847,
      "x": -1605,
      "y": 19124
    },
    {
      "height": 427,
      "id": "c7ce5ec3e6960490",
      "styleAttributes": {
      },
      "text": "### Хранимые процедуры (Stored Procedures)\n\n- **Что это:** Набор SQL-операторов (иногда с логикой управления потоком, такой как циклы и условия), который хранится в базе данных и может быть **вызван по имени** как единая единица.\n- **Назначение:**\n    - **Инкапсуляция логики:** Позволяет инкапсулировать сложную бизнес-логику на стороне БД, обеспечивая единый источник истины.\n    - **Повышение производительности:** Компилируются при первом вызове и кэшируются, что ускоряет последующие выполнения. Уменьшается сетевой трафик (вместо нескольких SQL-запросов отправляется один вызов процедуры).\n    - **Безопасность:** Можно предоставить пользователям разрешения на выполнение процедуры, не давая им прямого доступа к базовым таблицам.\n    - **Переиспользование кода:** Один раз написанная процедура может использоваться множеством приложений.\n- **Пример:** Процедура `PerformOrder(CustomerID, ItemID, Quantity)` может инкапсулировать логику создания нового заказа, проверки наличия товара, уменьшения количества товара и т.д.",
      "type": "text",
      "width": 1121,
      "x": -984,
      "y": 16296
    },
    {
      "height": 355,
      "id": "af5349b3dacc55a7",
      "styleAttributes": {
      },
      "text": "### Реляционность\n\nДанные организованы в виде двумерных таблиц\n- Таблицы\n- Схема - каждая таблица имеет строго определённую структуру\n- Ключи (PK, FK)\n- Связи (relationship):\n\t- 1-1 \n\t- 1-many (1 автор мог написать много книг)\n\t- many-many (студенты и курсы, которые они посещают)\n\n\n",
      "type": "text",
      "width": 704,
      "x": -1711,
      "y": 16035
    },
    {
      "height": 490,
      "id": "23984b90e1ef2dd1",
      "styleAttributes": {
      },
      "text": "### OLAP и OLTP\n- OLTP - для оперативной обработки транзакций (коротких атомарных; CRUD)\nФокус: операционная деятельность, ежедневные операции\nТип запросов: множество коротких небольших запросов\nСильная нормализованность, высокая скорость, критически важна строгая консистентность (поддержка ACID-транзакций)\nПрименение: банкинг, интернет-магазины, CRM, etc.\nПримеры: любые реляционные БД\n\n- OLAP - базы данных для аналитической обработки\nОптимизированы для сложных запросов над большими объемами исторических данных\nФокус: анализ данных, построение отчётов, бизнес-аналитика. ЫЧасто исторические данные. Денормализация. Оптимизированы для чтения и агрегации. Не требуется строгой ACID\nПримеры: Apache Druid, ClickHouse, Vertica, OLAP-кубы поверх реляционных БД",
      "type": "text",
      "width": 704,
      "x": -1711,
      "y": 15508
    },
    {
      "height": 877,
      "id": "7d27f2d2896d28be",
      "styleAttributes": {
      },
      "text": "### Асинхронность\n\n**На сервере**:\nСервер может обрабатывать несколько запросов одновременно, не блокируя процесс ожиданием (например, медленного ответа от БД, API или файла)\nНужна:\n- При обработке множества клиентов одновременно \n- Медленные операции:\n\t- запросы в БД\n\t- HTTP-запросы к внешним API\n\t- работа с файлами или сетью\n\n**На клиенте**:\nКлиент делает асинхронные вызовы, не блокируя остальную часть программы (например, пользовательский интерфейс или другие запросы).\nНужна:\n- В GUI или веб-приложении\n- Когда клиент вызывает несколько API одновременно\n- В чат-ботах, WebSocket приложениях и т.д.\n\n\n## 🧠 Кратко: зачем нужна асинхронность в GUI\n\n|Причина|Объяснение|\n|---|---|\n|✅ UI не \"зависает\"|Асинхронные операции не блокируют главный поток|\n|✅ Многозадачность|Можно выполнять несколько задач параллельно|\n|✅ Энергосбережение|ОС может эффективнее планировать задачи|\n|✅ Пользовательский комфорт|Интерфейс остаётся отзывчивым (анимации, клики, свайпы)|",
      "type": "text",
      "width": 861,
      "x": -2699,
      "y": 14452
    },
    {
      "file": "Pictures/eb2d6637.png",
      "height": 790,
      "id": "c5f040c01b91bd44",
      "styleAttributes": {
      },
      "type": "file",
      "width": 1189,
      "x": -1792,
      "y": 11512
    },
    {
      "height": 791,
      "id": "8968c63433c413ee",
      "styleAttributes": {
      },
      "text": "### Клиент, сервер\n**Клиент** - программа или устройство, которая инициирует запрос к другому устройству \nПримеры: браузер, почтовый клиент, мобильное приложение\n\n**Сервер** - программа или устройство, которая принимает запросы и отправляет ответ. \nПримеры: веб-сервер (Nginx, Apache), почтовый сервер (SMIP/IMAP), файловый сервер (FTP, SMB)\n\n**Взаимодействие (HTTP)**:\n1\\. Клиент (браузер) открывает сайт: `https://example.com`\n2\\. Он формирует HTTP-запрос: \n```\nGET / HTTP/1.1\nHost: example.com\n```\n3\\. Сервер получает запрос, обрабатывает его и отправляет ответ:\n```\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<html>...</html>\n```\n4\\. Браузер отображает страницу",
      "type": "text",
      "width": 1210,
      "x": -1796,
      "y": 12528
    },
    {
      "height": 834,
      "id": "2c5cf6567c3e02ef",
      "styleAttributes": {
      },
      "text": "### Про БД\n\n1\\. **Реляционность** - означает, что: 1) данные хранятся в таблицах (отношениях), 2) между которыми существуют связи\n\\* отношения из ТМ\n- Таблицы представляют собой отнношения \n- В каждой таблице: строки - записи (tuples), столбцы - атрибуты (поля)\n- Связи между таблицами устанавливаются через ключи: первичный ключ (Primary Key) - уникально идентифицирует запись, \n\n2\\. Проблемы, если запихнуть все данные в одну таблицу:\n- Дублирование данных - если в одной таблице заказ и клиент, то будут содержаться копии данных клиента в заказе\n- Сложность обновления (anomaly) - если имя клиента изменится, то придётся обновлять его во всех строках, где оно встречается\n- Нарушение нормализации \n- Сложно делать агрегацию, фильтрацию, индексацию при монолитной структуре\n- Трудности поддержки: добавить новое поле или изменить структуру сложно\n\n3\\. **Права**\n1\\) На уровне базы данных:\n- Кто может подключаться к базе\n- Кто может создавать таблицы, представления, процедуры и т.п.\n\n2\\) Права на уровне объектов (таблиц, представлений и т.п.):\nМожно указать, кто будет:\n- `SELECT` - читать\n- `INSERT` - добавлять\n- `UPDATE` - изменять\n- `DELETE` - удалять\n- `EXECUTE` - вызывать процедуры, функции\n\n3\\) Права на уровне строк или столбцов (в некоторых субд)",
      "type": "text",
      "width": 2136,
      "x": -439,
      "y": 12528
    },
    {
      "height": 1060,
      "id": "bcda69a3811547d9",
      "styleAttributes": {
      },
      "text": "### Нормализация БД\n**Нормализация** - процесс оргаанизации данных в бд с целью:\n- Уменьшить избыточность (дублирование данных)б\n- Избежать аномлий при вставке, удалении или обновлении\n- Разделить данные на логические таблицы, связанные между собой, через ключи\n\n1NF - таблица должна содержать только атомарные значения (одно значение в одной ячейке)\n**❌ Пример нарушения 1NF:**\n`Orders(id, customer_name, items) items = \"pen, notebook, eraser\"`\n**✅ Правильно (1NF):**\n`OrderItems(order_id, item)`\n\n2NF - 1NF + все неключевые столбцы должны зависеть от всего первичного ключа, а не от его части\n**❌ Пример нарушения 2NF:**\n`OrderItems(order_id, item_id, customer_name)`\n`customer_name` зависит только от `order_id`, а не от пары (`order_id`, `item_id`).\n**✅ Правильно (2NF):**\n`Orders(order_id, customer_name); OrderItems(order_id, item_id)`\n\n3NF - 2NF + не должно быть транзитивных зависимостей: неключевые поля не должны зависеть друг от друга. \n**❌ Пример нарушения 3NF:**\nEmployees(emp_id, name, dept_id, dept_name, dept_location)\nПроблема:\n- `dept_name` и `dept_location` зависят **не от `emp_id`**, а от `dept_id`, который сам зависит от `emp_id`.\n- Это — **транзитивная зависимость**:\n    - `emp_id → dept_id → dept_name, dept_location`\n\n**✅ Правильно (3NF):**\n`Employees(emp_id, name, department_id) Departments(department_id, department_name)`\n\n**Транзитивная зависимость** — это когда **неключевое поле зависит не от ключа напрямую, а через другое неключевое поле**\n## 🚫 Аномалии, которые решает нормализация\n\n|Тип аномалии|Пример проблемы|\n|---|---|\n|**Insert**|Нельзя записать нового клиента без заказа.|\n|**Update**|Изменение названия отдела требует правки в 100 строках.|\n|**Delete**|Удаляя последний заказ, можно случайно удалить и данные клиента.|\n",
      "type": "text",
      "width": 2136,
      "x": -439,
      "y": 13392
    },
    {
      "height": 2979,
      "id": "e188de54e7e614ad",
      "styleAttributes": {
      },
      "text": "||**Абстракция**|**Инкапсуляция**|\n|---|---|---|\n|**Что делает?**|Скрывает **сложность** и показывает **только суть**|Скрывает **внутреннее состояние** и защищает данные|\n|**Для чего?**|Чтобы **сфокусироваться на важном**|Чтобы **контролировать доступ** и защиту данных|\n|**Как достигается?**|Через **интерфейсы, абстрактные классы**|Через **модификаторы доступа, свойства (property)**|\n|**Кто \"пользователь\"?**|Разработчик, использующий класс или API|Разработчик **внутри** класса|\n\n**Инкапсуляция**\n```python\nclass User:\n    def __init__(self, name):\n        self.__name = name  # приватное поле\n\n    def get_name(self):     # геттер\n        return self.__name\n\n    def set_name(self, name):  # сеттер\n        if name:\n            self.__name = name\n\n```\n\n**Абстракция**\n\\* без наследования от ABC класс будет обычным\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):  # абстрактный класс\n    @abstractmethod\n    def make_sound(self):\n        pass\n\nclass Dog(Animal):\n    def make_sound(self):\n        print(\"Woof!\")\n\nclass Cat(Animal):\n    def make_sound(self):\n        print(\"Meow!\")\n```\n\n**Наследование**\nСоздание класса на основе существующего с наследованием его атрибутов и методов\n```python\nclass Parent:\n    def __init__(self, name):\n        print(f\"Parent init: {name}\")\n\nclass Child(Parent):\n    def __init__(self, name):\n        print(\"Child init\")\n        super().__init__(name)  # вызывает __init__ родителя, передаём все аргументы в ините родителя\n\nc = Child(\"Alice\")\n```\n- Override (переопределение)\n\n\n**Полиморфизм**\n\nDuck typing\n```python\nclass Dog:\n    def speak(self):\n        print(\"Woof!\")\n\nclass Cat:\n    def speak(self):\n        print(\"Meow!\")\n\ndef animal_speak(animal):\n    animal.speak()  # не важно, что за класс\n\nanimal_speak(Dog())  # Woof!\nanimal_speak(Cat())  # Meow!\n```\n\nПереопределение методов\n```python\nclass Shape:\n    def area(self):\n        raise NotImplementedError\n\nclass Circle(Shape):\n    def area(self):\n        return 3.14 * 5 * 5\n```\n\nПерегрузка методов - несколько методов с одним и тем же именем, но разными параметрами.\n\n\n```java\nclass MyClass {\n    void doSomething() {}\n    void doSomething(String msg) {}\n    void doSomething(int x, int y) {}\n}\n```\n1\\. Значения по умолчанию\n```python\nclass MyClass:\n    def greet(self, name=None):\n        if name:\n            print(f\"Hello, {name}!\")\n        else:\n            print(\"Hello!\")\n\nobj = MyClass()\nobj.greet()          # Hello!\nobj.greet(\"Alice\")   # Hello, Alice!\n\n```\n\n2\\. Использовать `*args` и `**kwargs`\n\n\n|Способ|Когда использовать|\n|---|---|\n|Значения по умолчанию|Простая логика, один метод|\n|`*args`, `**kwargs`|Гибкость, переменное число аргументов|\n|`isinstance()`|Разные типы входа|\n|`singledispatch`|Перегрузка по типу (функции)|\n|`singledispatchmethod`|Перегрузка по типу (методы классов)|\n|`operator overloading`|Переопределение `+`, `*`, `==` и т.д.|\n|`typing.overload`|Поддержка IDE и type checker'ов|",
      "type": "text",
      "width": 1039,
      "x": 3154,
      "y": 11564
    },
    {
      "height": 60,
      "id": "2ebc38dc662f437f",
      "styleAttributes": {
      },
      "text": "",
      "type": "text",
      "width": 260,
      "x": -2670,
      "y": 16152
    },
    {
      "height": 1889,
      "id": "9ba3ab52ca5f0632",
      "styleAttributes": {
      },
      "text": "### OSI модель (7 уровней) + протоколы\n\n**OSI (Open Systems Interconnection)** - концептуальный фреймворк, который разделяет сетевые коммуникации на 7 уровней, каждый со своими специфическими функциями и отвественностью. Стандартизированная модель, которая позволяет разным приложениям и компьютерным системам коммуницировать, обеспечивая взаимодействие между различными сетевыми технологиями и протоколами.\n\n1\\. **Физический уровень (Physical layer)**\nНазначение: передача необработанных битов по физической среде\n\n- **Ethernet** - стандарты\n- **USB / DSL / IDSN / Wi-Fi** - физические стандарты\n- **Bluetooth**, **NFC** - беспроводные стандарты\n\n2\\. **Канальный уровень (Data Link Layer)**\nНазначение: Обеспечение передачи кадров между узлами одной сети. Работа с MAC-адресами\n- **Ethernet** — основа локальных сетей.\n    \n- **PPP** — point-to-point соединение (модемы).\n    \n- **Frame Relay** — старый протокол WAN.\n    \n- **HDLC** — синхронный протокол передачи данных.\n    \n- **MAC** — подуровень управления доступом к среде.\n\n3\\. **Сетевой уровень (Network Layer)**\nНазначение: Определение маршрутов и логических адресов, доставка пакетов между хостами\n- **IP (IPv4 / IPv6)** — адресация и маршрутизация.\n    \n- **ICMP** — диагностика сети (например, `ping`).\n    \n- **ARP** — преобразование IP-адреса в MAC-адрес.\n    \n- **IGMP** — управление группами (multicast).\n    \n- **IPSec** — безопасная передача на IP-уровне.\n    \n4\\. **Транспортный уровень (Transport Layer)**\nНазначение: Обеспечение доставки данных, управление потоками и ошибками\n\n- **TCP** - надёжная доставка, контроль потока, порядок\n- **UDP** - ненадёжная, но быстрая доставка (без гарантии)\n- **SCTP** — альтернатива TCP с поддержкой мультипоточности\n\n5\\. **Сеансовый уровень (Session Layer)**\nНазначение: Управление сессиями: установление, поддержка и завершение протоколов связи между приложениями\nПротоколы:\n- **NetBIOS** - сессии Windows-сетей\n- **RPC**  (Remote Procedure Call) - удалённое выполнение процедур\n- **PPTP** - устаревший VPN-протокол\n\n6\\. **Представительский уровень (Presentation Layer)**\nНазначение: Преобразование данных - кодирование, сжатие, шифрование/дешифрование\nПротоколы (неявно реализованы, часто встроены в приложения):\n- **SSL / TSL** - шифрование данных\n- **MIME** - кодирование e-mail вложений\n\n7\\. **Прикладной уровень**\nНазначение: Обеспечивает взаимодействие приложений с сетью. Пользовательский интерфейс с сетью.\nПротоколы:\n- **HTTP / HTTPS** - передача веб страниц\n- **FTP / SFTP** - передача файлов\n- **SMTP / IMAP / POP3** - электронная почта\n- **DNS** - преобразование доменных имён в IP\n- **Telnet / SSH** - удалённый доступ к устройствам\n- **SNMP** - управление сетевыми устройствами\n\n\n\n",
      "type": "text",
      "width": 861,
      "x": -2699,
      "y": 12528
    },
    {
      "height": 1291,
      "id": "ff2a7e1dbb0a097c",
      "styleAttributes": {
      },
      "text": "### HTTP коды статуса\n\n`HTTP/1.1 200 OK`\n\n**1xx - Informational (информационные)**\nПромежуточные, редко используемые вручную\n\n100 Continue (клиент может продолжить запрос)\n101 Switching Protocols Сервер \n102 Processing (WebDAV) Сервер начал, но не закончил выполнение\n\n**2xx - Success (успешные)**\n200 OK\n201 Created\n202 Accepted\n204 No content\n\n**3xx - Redirection**\n_Клиент должен сделать что-то ещё_\n301 Moved Permanently\n302 Found (Temporary)\n304 Not modified Кэш актуален, тело не передаётся\n307 Temporary Redirect Без смены метода запроса\n\n**4xx - Client Error (ошибки клиента)**\n400 Bad Request - неверный синтаксис запроса\n401 Unauthorized - требуется авторизация\n403 Forbidden - Запрещён доступ (даже с логином)\n404 Not found - Ресурс не найден\n409 Conflict - Конфликт состояния (например, ID занят)\n422 Unprocessable Entity - Валидация не прошла (часто в API)\n\n**5xx - Server errors (ошибки сервера)**\n500 Internal server error\n501 Not implemented - метод не реализован\n502 Bad Gateway - ошибка на промежуточном сервере\n503 Service Unavailable - Сервис временно недоступен\n504 Gateway Timeout Прокси не дождался ответа от сервера\n\n## ✅ Мини-памятка: топовые коды\n\n| Код   | Где часто встречается       |\n| ----- | --------------------------- |\n| `200` | Успешный `GET/POST`         |\n| `201` | Успешный `POST` (создание)  |\n| `204` | Успешный `DELETE`           |\n| `400` | Ошибочный запрос            |\n| `401` | Нет токена или токен плохой |\n| `403` | Токен есть, но доступа нет  |\n| `404` | Неверный путь / id          |\n| `500` | Баг на сервере              |",
      "type": "text",
      "width": 1210,
      "x": -1796,
      "y": 13362
    },
    {
      "color": "6",
      "height": 945,
      "id": "d838732f20bf37e9",
      "styleAttributes": {
      },
      "text": "### Классы 4\n\n**Dunder methods**\n\n- Lifecycle\n- Comparison\n- Arithmetic\n- Container\n- Context manager\n- Callable\n\n**Slots** - `__slots__` для оптимизации (раз в 5 по памяти, немного по производительности)\n\n**Дескрипторы**\nКлассы с `__get__`, `__set__`, `__delete__`\n\n**ООП**: Абстракция, наследование, инкапсуляция, полиморфизм\n\n**Принципы**\nDRY, KISS, YAGNI\n\n_SOLID_ - это аббревиатура от 5 принципов, описанных Робертом Мартином, которые способствуют созданию хорошего объектно-ориентированного (и не только) кода.\nSOLID:\n- Single responsibility principle: класс решает одну задачу\n- Open-Closed Principle - открытость для расширения, но не для модификации\n-  Liskov Substitution Principle -  необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов\n- Interface Segregation Principle - Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют\n- Dependency Inversion Principle (Принцип инверсии зависимостей) -  Объектом зависимости должна быть абстракция, а не что-то конкретное; Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.",
      "type": "text",
      "width": 733,
      "x": -3420,
      "y": 8249
    },
    {
      "height": 596,
      "id": "607ef97610398f28",
      "styleAttributes": {
      },
      "text": "### Advanced loop patterns\nEnumerate\n```python\nfor index, fruit in enumerate(fruits, start=1):\n    print(f\"Item {index}: {fruit}\")  # Starts from 1, not 0\n```\nZip\n```python\nnames = ['Alice', 'Bob', 'Charlie']\nages = [25, 30, 35] \ncities = ['New York', 'London', 'Tokyo'] # Process all three lists simultaneously \nfor name, age, city in zip(names, ages, cities): \n\tprint(f\"{name} is {age} years old and lives in {city}\")\n```\n\nItertools\n```python\nitertools.cycle(colors)\nitertools.chain(list1, list2, list3)\nitertools.combinations(team, 2)\n```",
      "type": "text",
      "width": 771,
      "x": -3418,
      "y": 4428
    },
    {
      "height": 862,
      "id": "7806bfdd7e47b6f9",
      "styleAttributes": {
      },
      "text": "### Comprehensions with Conditions\n#### List Comprehensions\n`[expression for item in iterable if condition]`\n```python\nsquares = [x**2 for x in range(10)]\neven_squares = [x**2 for x in range(10) if x % 2 == 0]\ncapitalized_long_words = [word.upper() for word in words if len(word) > 5]\n# Nested comprehensions (be careful with readability) \nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \nflattened = [num for row in matrix for num in row]\n```\n#### Dict Comprehensions\n`{key_expr: value_expr for item in iterable if condition}`\n```python\nsquare_dict = {x: x**2 for x in range(5)}\nword_lengths = {word: len(word) for word in words if len(word) > 4}\nswapped = {value: key for key, value in original.items() if value % 2 == 0}\n```\n#### Set Comprehensions\n```python\nsentences = [\"hello world\", \"python programming\", \"data science\"] \nword_lengths = {len(word) for sentence in sentences for word in sentence.split()}\n```\n\n#### Generator expressions\n```python\nlarge_generator = (x**2 for x in range(1000000) if x % 2 == 0)\ntotal = sum(numbers_gen)\n```",
      "type": "text",
      "width": 771,
      "x": -3418,
      "y": 5075
    },
    {
      "height": 919,
      "id": "9ee1f9e8be477335",
      "styleAttributes": {
      },
      "text": "### Walrus operator `:=`\nWalrus operator allows assignment within expressions\n```python\n# Traditional approach requires repetition\nuser_input = input(\"Enter a number: \")\nif len(user_input) > 5:\n    print(f\"Long input: {user_input}\")\n\n# With walrus operator - assign and check length in one line\nif (n := len(input(\"Enter a number: \"))) > 5:\n    print(f\"Input length is {n}\")\n```\nPowerful in loops and comprehensions\n```python\nlines = []\nwhile (line := input(\"Enter a line (empty to stop): \")) != \"\":\n    lines.append(line.upper())\n\n# In list comprehensions for complex filtering\nimport re\ntext = [\"hello123\", \"world\", \"python456\", \"code\"]\n# Extract numbers from strings that contain them\nnumbers = [match.group() for string in text \n           if (match := re.search(r'\\d+', string))]\n# Results in: ['123', '456']\n\n# Processing function results\ndef expensive_computation(x):\n    print(f\"Computing for {x}\")  # Simulate expensive operation\n    return x ** 2\n\n# Without walrus operator - computation happens twice\ndata = [1, 2, 3, 4, 5]\nresults = [expensive_computation(x) for x in data if expensive_computation(x) > 10]\n\n# With walrus operator - computation happens only once\nresults = [result for x in data if (result := expensive_computation(x)) > 10]\n```",
      "type": "text",
      "width": 771,
      "x": -3418,
      "y": 5993
    }
  ]
}