{
	"nodes":[
		{"id":"90edff8d254d6726","type":"text","text":"\n### 1. SELECT\n\n#### 1.1. SELECT, FROM\n```SQL\nSELECT column1, column2, ...\nFROM table_name;\n\nSELECT * FROM Customers;\nSELECT CustomerName, City FROM Customers;\n```\n#### 1.2. DISTINCT\n```SQL\nSELECT DISTINCT column1, column2, ...\nFROM table_name;\n\nSELECT DISTINCT Country FROM Customers;\nSELECT COUNT(DISTINCT Country) FROM Customers;\nSELECT COUNT(*) AS DistinctCountries\nFROM (SELECT DISTINCT Country FROM Customers);\n```\n#### 1.3. WHERE\n```SQL\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n\nSELECT * FROM Customers\nWHERE Country = 'Mexico'; # CustomerId > 80; \n```\n#### 1.4. ORDER BY, ASC, DESC\n```SQL\nSELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... ASC|DESC;\n\nSELECT * FROM Products\nORDER BY Price;\nSELECT * FROM Customers\nORDER BY Country ASC, CustomerName DESC;\n```\n#### 1.5. AND, OR,  NOT, LIKE\n```SQL\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition1 AND condition2 AND condition3 ...\n\nSELECT * FROM Customers\nWHERE Country = 'Spain' AND CustomerName LIKE 'G%' OR CustomerName LIKE 'R%'\n\nSELECT * FROM Customers\nWHERE NOT Country = 'Spain'; # NOT IN ('Paris', 'London')\n```\n#### 1.6. NULL check\n```SQL\nSELECT column_names\nFROM table_name\nWHERE column_name IS NOT NULL;\n```\n#### 1.7. TOP, LIMIT\n```SQL\nSELECT TOP number|percent column_name(s)   # SQL Server / MS Access\nFROM table_name\nWHERE condition;\n\nSELECT column_name(s) \nFROM table_name\nWHERE condition\nLIMIT number;\n\nSELECT TOP 3 * FROM Customers;\n\nSELECT * FROM Customers\nWHERE Country = 'Germany'\nLIMIT 3;\n\nSELECT * FROM Customers\nORDER BY CustomerName DESC\nLIMIT 3;\n```\n\n#### 1.8. Aggregating functions: MAX, MIN, COUNT, SUM, AVG, GROUP BY\n```SQL\nSELECT MIN(column_name) # MAX, SUM\nFROM table_name\nWHERE condition;\n\nSELECT MIN(Price) #MAX, SUM\nFROM Products;\n\nSELECT MIN(Price) AS SmallestPrice, CategoryID\nFROM Products\nGROUP BY CategoryID;\n\nSELECT COUNT(DISTINCT Price)\nFROM Products;\n\nSELECT COUNT(*) AS [Number of records], CategoryID\nFROM Products\nGROUP BY CategoryID;\n\nSELECT SUM(Quantity) as total\nFROM OrderDetails\nWHERE ProductID = 11;\n\nSELECT AVG(Price)  \nFROM Products;\n```\n\n#### 1.9. LIKE\n```SQL\nSELECT column1, column2, ...\nFROM table_name\nWHERE column LIKE pattern;\n\nSELECT * FROM Customers\nWHERE CustomerName LIKE 'a%'\n\nSELECT * FROM Customers\nWHERE city LIKE 'L_nd__'\n\nSELECT * FROM Customers  \nWHERE city LIKE '%L%';\n\n```\n#### 1.10 Wildcards: %, _, [], ^, -, {}\n```SQL\nSELECT * FROM Customers  \nWHERE CustomerName LIKE '[a-f]%';\n```\n\n#### 1.11 IN\n```SQL\nSELECT * FROM Customers\nWHERE Country IN ('Germany', 'France')\nSELECT * FROM Customers\nWHERE CustomerID NOT IN (SELECT CustomerID FROM Orders);\n```\n#### 1.12 BETWEEN\n```SQL\nSELECT * FROM Products\nWHERE Price BETWEEN 10 AND 20;\n```\n\n#### 1.13 Aliases: AS\n```SQL\nSELECT column_name AS alias_name\nFROM table_name;\n\nSELECT CustomerID AS ID\nFROM Customers;\n\nSELECT ProductName AS [My Great Products] # \"My Great Products\"\nFROM Products;\n\nSELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address\nFROM Customers;\n```","x":-300,"y":-500,"width":860,"height":4080},
		{"id":"fc6111c85b3df0bc","type":"text","text":"## Basics","x":-300,"y":-560,"width":250,"height":60},
		{"id":"abbdda9984eb0276","type":"text","text":"#### 3 CRUD\n#### 3.1. CREATE, DROP, BACKUP database\n```SQL\nCREATE DATABASE _databasename_;\n\nDROP DATABASE _databasename_;\n\nBACKUP DATABASE _databasename_  \nTO DISK = '_filepath_'; --WITH DIFFERENTIAL;\n```\n\n#### 3.2. CREATE, DROP, ALTER table\n```SQL\nCREATE TABLE _table_name_ (  \n    _column1 datatype_,  \n    _column2 datatype_,  \n    _column3 datatype_,  \n   ....  \n);\nCREATE TABLE _new_table_name_ AS  \n    SELECT _column1, column2,..._  \n    FROM _existing_table_name_  \n    WHERE ....;\n\nDROP TABLE _table_name_;\nTRUNCATE TABLE _table_name_;\n\nALTER TABLE _table_name_  \nADD _column_name datatype_;\nALTER TABLE _table_name_  \nDROP COLUMN _column_name_;\nALTER TABLE _table_name_  \nRENAME COLUMN _old_name_ to _new_name_;\nALTER TABLE _table_name_  \nMODIFY COLUMN _column_name datatype_;\n```\n\n#### 3.3. Create Constraints\n```SQL \nCREATE TABLE _table_name_ (  \n    _column1 datatype_ _constraint_,  \n    _column2 datatype_ _constraint_,  \n    _column3 datatype_ _constraint_,  \n    ....  \n);\n```\n- `[NOT NULL] - Ensures that a column cannot have a NULL value\n- `[UNIQUE] - Ensures that all values in a column are different\n- `[PRIMARY KEY] - A combination of a `NOT NULL` and `UNIQUE`. Uniquely identifies each row in a table\n- `[FOREIGN KEY] - Prevents actions that would destroy links between tables\n- `[CHECK] - Ensures that the values in a column satisfies a specific condition\n- `[DEFAULT] - Sets a default value for a column if no value is specified\n- `[CREATE INDEX]` - Used to create and retrieve data from the database very quickly\n\n```SQL\nCREATE TABLE Persons (  \n    ID int NOT NULL,  \n    LastName varchar(255) NOT NULL,  \n    FirstName varchar(255) NOT NULL,  \n    Age int  \n);\n\nCREATE TABLE Persons (  \n    ID int NOT NULL UNIQUE,  \n    LastName varchar(255) NOT NULL,  \n    FirstName varchar(255),  \n    Age int  \n);\nCREATE TABLE Persons (  \n    ID int NOT NULL,  \n    LastName varchar(255) NOT NULL,  \n    FirstName varchar(255),  \n    Age int,  \n    UNIQUE (ID)  \n);\n```\nThe `PRIMARY KEY` constraint uniquely identifies each record in a table.\nPrimary keys must contain UNIQUE values, and cannot contain NULL values.\nA table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields).\n```SQL\nCREATE TABLE Persons (  \n    ID int NOT NULL,  \n    LastName varchar(255) NOT NULL,  \n    FirstName varchar(255),  \n    Age int,  \n    CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)  \n);\n```\nThe `FOREIGN KEY` constraint is used to prevent actions that would destroy links between tables.\nA `FOREIGN KEY` is a field (or collection of fields) in one table, that refers to the `[PRIMARY KEY]` in another table.\nThe table with the foreign key is called the child table, and the table with the primary key is called the referenced or parent table.\n``` SQL\nCREATE TABLE Orders (  \n    OrderID int NOT NULL,  \n    OrderNumber int NOT NULL,  \n    PersonID int,  \n    PRIMARY KEY (OrderID),  \n    FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)  \n);\n```\nThe `CHECK` constraint is used to limit the value range that can be placed in a column.\nIf you define a `CHECK` constraint on a column it will allow only certain values for this column.\nIf you define a `CHECK` constraint on a table it can limit the values in certain columns based on values in other columns in the row.\n```SQL\nCREATE TABLE Persons (  \n    ID int NOT NULL,  \n    LastName varchar(255) NOT NULL,  \n    FirstName varchar(255),  \n    Age int,  \n    CHECK (Age>=18)  \n);\n```\nThe `DEFAULT` constraint is used to set a default value for a column.\nThe default value will be added to all new records, if no other value is specified.\n```SQL\nCREATE TABLE Persons (  \n    ID int NOT NULL,  \n    LastName varchar(255) NOT NULL,  \n    FirstName varchar(255),  \n    Age int,  \n    City varchar(255) DEFAULT 'Sandnes'  \n);\n```\n\n```SQL\nCREATE UNIQUE INDEX _index_name_  \nON _table_name_ (_column1_, _column2_, ...);\n```\n#### 3.4. INSERT\n```SQL\nINSERT INTO table_name (column1, column2, ...)\nVALUES (value1, value2, ...)\n\nINSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)  \nVALUES \n('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway'),  \n('Greasy Burger', 'Per Olsen', 'Gateveien 15', 'Sandnes', '4306', 'Norway'),  \n('Tasty Tee', 'Finn Egan', 'Streetroad 19B', 'Liverpool', 'L1 0AA', 'UK');\n```\n#### 3.5. UPDATE\n``` SQL\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n\nUPDATE Customers\nSET ContactName = 'Juan'\nWHERE Country = 'Mexico';\n```\n#### 3.6. DELETE, DROP\n```SQL \nDELETE FROM table_name WHERE condition;\n\nDELETE FROM Customers WHERE CustomerName = 'Alfreds Futterkiste';\nDELETE FROM table_name;\n\n```","x":1720,"y":-500,"width":860,"height":3560},
		{"id":"36842f7056737110","type":"text","text":"### 2. JOIN\n\n#### 2.1. JOIN\nJOIN - to combine 2+ tables based on a related column between them\n```SQL\nSELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate  \nFROM Orders  \nINNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;\n```\nINNER JOIN - records matching both tables\nLEFT (OUTER) JOIN - all records from the left table, and the matched records from the right table\nRIGHT (OUTER) JOIN - all records from the right table, and the matched records from the left table\nFULL (OUTER) JOIN - all records when there is a match in either left or right table\n```SQL\nSELECT column_name(s)\nFROM table1\nJOIN table2\nON table1.column_name = table2.column_name;\n```\nSelf JOIN - table is joined with itself\n\n#### 2.2. UNION\n```SQL\nSELECT column_name(s) FROM table1\nUNION \nSELECT column_name(s) FROM table2;\n```\nUNION ALL to select duplicates\n\n```SQL\nSELECT City, Country FROM Customers  \nWHERE Country='Germany'  \nUNION  \nSELECT City, Country FROM Suppliers  \nWHERE Country='Germany'  \nORDER BY City;\n```\n\n#### 2.3. GROUP BY\nThe GROUP BY statement groups rows that have the same values into summary rows, like \"find the number of customers in each country\".\n\n```SQL\nSELECT column_name(s)\nFROM table_name \nWHERE condition  \nGROUP BY column_name(s)  \nORDER BY column_name(s);\n```\n\n#### 2.4. HAVING\nThe HAVING clause was added to SQL because the WHERE keyword cannot be used with aggregate functions.\n```SQL\nSELECT column_name(s)  \nFROM table_name\nWHERE condition  \nGROUP BY column_name(s)  \nHAVING condition  \nORDER BY column_name(s);\n\n#The following SQL statement lists the number of customers in each country. Only include countries with more than 5 customers:\nSELECT COUNT(CustomerID), Country\nFROM Customers\nGROUP BY Country\nHAVING COUNT(CustomerID) > 5;\n\n#The following SQL statement lists the employees that have registered more than 10 orders:\nSELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders  \nFROM (Orders JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID)  \nGROUP BY LastName  \nHAVING COUNT(Orders.OrderID) > 10;\n\n#The following SQL statement lists if the employees \"Davolio\" or \"Fuller\" have registered more than 25 orders:\nSELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders  \nFROM Orders  \nINNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID  \nWHERE LastName = 'Davolio' OR LastName = 'Fuller'  \nGROUP BY LastName  \nHAVING COUNT(Orders.OrderID) > 25;\n```\n\n#### 2.5. EXISTS\n```SQL\nSELECT _column_name(s)_  \nFROM _table_name_  \nWHERE EXISTS  \n(SELECT _column_name_ FROM _table_name_ WHERE _condition_);\n```\n\n#### 2.6. ANY, ALL\nThe ALL operator:\n- returns a boolean value as a result\n- returns TRUE if ALL of the subquery values meet the condition\n- is used with `SELECT`, `WHERE` and `HAVING` statements\n\nANY:\n- returns a boolean value as a result\n- returns TRUE if ANY of the subquery values meet the condition\n```SQL\nSELECT _column_name(s)_  \nFROM _table_name_  \nWHERE _column_name operator_ ANY  \n  (SELECT _column_name_  FROM _table_name_  WHERE _condition_);\n```\n\n#### 2.7. SELECT INTO\nThe `SELECT INTO` statement copies data from one table into a new table.\n```SQL\nSELECT _column1_, _column2_, _column3_, ...  \nINTO _newtable_ [IN _externaldb_]  \nFROM _oldtable  \n_WHERE _condition;_\n```\n\n#### 2.8. INSERT INTO SELECT\nThe `INSERT INTO SELECT` statement copies data from one table and inserts it into another table.\n```SQL\nINSERT INTO _table2_  \nSELECT * FROM _table1  \nWHERE _condition_;\n```\n\n","x":600,"y":-500,"width":1080,"height":2980},
		{"id":"2ed11a236579141c","type":"text","text":"### 4. Aux stuff\n#### 4.1. CASE\n```SQL\nCASE  \n    WHEN _condition1_ THEN _result1_  \n    WHEN _condition2_ THEN _result2_  \n    WHEN _conditionN_ THEN _resultN_  \n    ELSE _result_  \nEND;\n```\n\n#### 4.2. IFNULL(), ISNULL(), COALESCE(), and NVL()\n\n```SQL\nSELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))  \nFROM Products;\n```\n\n#### 4.3. SQL Stored Procedures\n```SQL\nCREATE PROCEDURE _procedure_name_  \nAS  \n_sql_statement_  \nGO;\n\nEXEC _procedure_name_;\n```\n\n```SQL\nCREATE PROCEDURE SelectAllCustomers  \nAS  \nSELECT * FROM Customers  \nGO;\n\nEXEC SelectAllCustomers;\n```\n\n#### 4.4. Comments\n```SQL\n-- SELECT * FROM Customers;\n/*Select all the columns  \nof all the records  \nin the Customers table:*/\n```\n\n#### 4.5. Operators","x":2640,"y":-500,"width":800,"height":1140},
		{"id":"a5b2457fc0570c76","type":"text","text":"#### Простые выборки\n\nСинтаксис:\n```SQL\nSELECT column(s)\nFROM table;\n```\nSELECT\n\n```SQL\nSELECT * FROM customers;\n\nSELECT conact_name, city\nFROM customers;\n\nSELECT order_id, shipped_date - order_date\nFROM orders;\n\nSELECT DISTINCT city, country\nFROM customers;\n\nSELECT COUNT(*)\nFROM customers;\n\nSELECT COUNT(DISTINCT country)\nFROM customers;\n```","x":-300,"y":3920,"width":380,"height":640},
		{"id":"f9cc4ea9bf3ae648","type":"text","text":"### Примеры запросов","x":-300,"y":3840,"width":380,"height":80},
		{"id":"46066fae1f21a661","type":"text","text":"#### Фильтрация - WHERE | AND, OR, NOT | BETWEEN, IN | ORDER BY, ASC, DESC | MIN, AVG, MAX\n\nСинтаксис:\n```SQL\nSELECT column(s)\nFROM table\nWHERE condition;\n```\nWHERE\n```SQL\nSELECT COUNT(*)\nFROM products\nWHERE unit_price > 20;\n\nSELECT * \nFROM customers\nWHERE city <> 'Berlin';\n\nSELECT *\nFROM orders\nWHERE date = '1998-03-01';\n```\nAND, OR\n```SQL\nSELECT *\nFROM products\nWHERE unit_price > 25 AND units_in_stock > 40;\n\nSELECT *\nFROM customers\nWHERE city = 'Betlin' AND (freight < 75 OR freight > 150);\n```\nBETWEEN\n```SQL\nSELECT COUNT(*)\nFROM orders\nWHERE freight BETWEEN 20 AND 40; -- including\n```\nIN, NOT\n```SQL\nSELECT *\nFROM customers\nWHERE country IN ('Mexico', 'Germany', 'USA', 'Canada')\n\nSELECT *\nFROM customers\nWHERE country NOT IN ('Mexico', 'Germany', 'USA', 'Canada')\n```\nORDER BY, ASC, DESC\n```SQL\nSELECT DISTINCT country, city\nFROM customers\nORDER BY country DESC, city ASC\n```\nMIN, MAX, AVG\n```SQL\nSELECT ship_city, order_date\nFROM orders\nWHERE ship_city = 'London'\nORDER BY order_date DESC\n\nSELECT AVG(unit_price) --SUM\nFROM products\nWHERE discontinued <> 1;\n```\n","x":80,"y":3920,"width":860,"height":1560},
		{"id":"ff6958c7c9ed6624","type":"text","text":"#### JOIN\nJOIN\n```SQL\nSELECT category_nme, SUM(unit_price * units_in_stock)\nFROM products\nJOIN categories ON products.category_id = categories.category_id\nWHERE discontinued <> 1\nGROUP BY category_name\nHAVING SUM(unit_price * units_in_stock) > 5000\nORDER BY SUM(unit_price * units_in_stock) DESC\n\nSELECT order_date, product_name, ship_county, products.unit_price, quantity, discount \nFROM orders\nJOIN order_details ON orders.order_id = order_details.order_id\nJOIN products ON order_tetails.product_id = product.product_id\n\nSELECT contact_name, company_name, phone, first_name, last_name, title, order_date, product_name, ship_country, products.unit_price, quantity, discount\nFROM orders\nJOIN order_details ON orders.order_id = order_details.order_id\nJOIN products ON order_details.product_id = products.product_id\nJOIN customers ON orders.customer_id = customers.customer_id\nJOIN employees ON orders.employee_id = employees.employee_id\nWHERE ship_country = 'USA'\n```\n```\nLEFT (RIGHT, CROSS) JOIN\n\n```SQL\nSELECT company_name, product_name\nFROM suppliers\nLEFT JOIN products ON suppliers.supplier_id = products.supplier_id\n```\nSELF JOIN\n\n```SQL\nCREATE TABLE employee (\n\temployee_id INT PRIMARY KEY\n\tmanager_id INT\n\tFOREIGN KEY (manager_id) REFERENCES employee (employee_id)\n)\n\nSELECT e.employee_id AS employee, m.manager_id AS manager\nFROM employee e\nLEFT JOIN employee m ON m.employee_id = e.manager_id\n```","x":940,"y":3920,"width":660,"height":1120},
		{"id":"259932ebc95443f3","type":"text","text":"#### Подзапросы\n\n```SQL\nSELECT DISTINCT country\nFROM customers\nWHERE country IN (\n\tSELECT DISTINCT country\n\tFROM customers\n)\n-- same as\nSELECT DISTINCT suppliers.company_name\nFROM suppliers\nJOIN customers USING(country)\n```\n\n```SQL\nSELECT category_name, SUM(units_in_stock)\nFROM products\nJOIN categories USING(category_id)\nGROUP BY category_name\nORDER BY SUM(units_in_stock) DESC\nLIMIT (SELECT MIN(product_id) + 4 FROM products)\n```\n\nWHERE EXISTS\nКомпании и имена заказчиков, которые делали заказы весом от 50 до 100\n```SQL\nSELECT company-name, contact_name\nFROM customers\nWHERE EXISTS (\n\tSELECT customer_id FROM orders\n\tWHERE customer_id  = customers.customer_id\n\tAND freight BETWEEN 50 AND 100)\n```\n\nANY\n```SQL\nSELECT DISTINCT company_name\nFROM customers\nWHERE customer_id = ANY(\n\tSELECT customer_id\n\tFROM orders \n\tJOIN order_details USING(order_id)\n\tWHERE quantity > 40\n)\n```","x":1600,"y":3920,"width":760,"height":1120},
		{"id":"986919daadbd4f30","type":"text","text":"#### DDL (CRUD stuf)\n\n```SQL\nCREATE TABLE table_name\n\nALTER TABLE table_name\n\tADD COLUMN column_name\n\tRENAME TO new_table_name\n\tRENAME old_column_name TO new_column_name\n\tALTER COLUMN column_name SET DATA TYPE data_type\n\nDROP table\nTRUNCATE table\nDROP COLUMN column_name\n\nINSERT INTO table_name VALUES\n```\n\nPRIMARY KEY - не можем вставить дубликат, null\n\n```SQL\nCREATE TABLE chair (\n\tchair_id SERIAL PRIMARY KEY,\n\tchair_name VARCHAR,\n\tdeat VARCHAR\n)\n\nCREATE TABLE chair (\n\tchair_id UNIQUE NOT NULL, -- разница в том, что мб несколько\n\tchair_name VARCHAR,\n\tdeat VARCHAR\n)\n```\n\nFOREIGN KEY\n\n```SQL\nALTER TABLE book\nADD CONSTRAINT FK_books_publisher FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id)\n```\n\nCHECK\n\n```SQL\nALTER TABLE book\n\tADD COLUMN price decimal CONSTRAINT CHK_book_price CHECK (price >= 0);\n```\n\nDEFAULT\n```CREATE TABLE customer (\n\tcustomer_id serial\n\tfull_name text,\n\tstatus char DEFAULT 'r',\n\n\tCONSTRAINT PK_customer_customer_id PRIMARY KEY(customer_id),\n\tCONSTRAINT CHK_customer_status CHECK (status = 'r' OR status = 'p')\n);\n```\n\nSEQUENCE\n\n```SQL\nCREATE SEQUENCE seq1;\n\nSELECT nextval('seq1');\nSELECT currval('seq1');\nSELECT lastval();\n\nSELECT setval('seq1', 16, true);\n\nCREATE SEQUENCE IF NOT EXISTS seq2 INCREMENT 16;\nSELECT nextval('seq2');\n\nCREATE SEQUENCE IF NOT EXISTS seq3\nINCREMENT 16\nMINVALUE 0\nMAXVALUE 128\nSTART WITH 0;\n```\n\nSERIAL\n\n```SQL\nCREATE SEQUENCE IF NOT EXISTS book_book_id_seq\nSTART WITH 1 OWNED BY book.book_id;\n\n...\n\tbook_id SERIAL\n...\n```\n\nINSERT, UPDATE, DELETE, RETURNING\n\n```SQL\nSELECT *\nINTO best_authors\nFROM author\nWHERE rating > 4.5\n\nSELECT * FROM best_authors\n\nUPDATE author\nSET full_name = 'Elias', rating = 5\nWHERE author_id = 1\n\nDELETE FROM author\nWHERE rating < 4.5\n\nTRUNCATE TABLE author;\n\nINSERT INTO book (title, isbn, publisher_id)\nVALUES ('title', 'isbn', 3)\nRETURNING book_id\n```\n","x":2360,"y":3920,"width":880,"height":2460},
		{"id":"ed9aa46f5f8cbbcb","type":"text","text":"#### Логика\n\nCASE WHEN \n\n```SQL\nCASE\n\tWHEN condition_1 THEN result_1\n\tWHEN condition_2 THEN result_2\n\t[WHEN ...]\n\t[ELSE result_n]\nEND\n\nSELECT product_name, unit_price, units_in_stock,\n\tCASE WHEN units_in_stock >= 100 THEN 'lots of'\n\t\t WHEN units_in_stock >= 50 AND units_in_stock < 100 THEN 'average'\n\t\t WHEN units_in_stock < 50 THEN 'low number'\n\t\t ELSE 'unkownw'\n\tEND AS amount\nFROM products\nORDER BY units_in_stock DESC;\n```\n\nCOALESCE\n\n```SQL\nCOALESCE(arg_1, arg2, ...); -- возвращает первый элемент не null (если все null, то null)\nNULLIF (arg1, arg2); -- если равны, то возвращает null\n\nSELECT order_id, order_date, COALESCE(ship_region, 'unkonwn') AS ship_region\nFROM orders\nLIMIT 10;\n\nSELECT contact_name, COALESCE(NULLIF(city, '), 'Unkown') AS city \nFROM customers;\n```","x":3240,"y":3920,"width":920,"height":1640},
		{"id":"42257f2305a97c37","type":"text","text":"### Типы данных","x":-1720,"y":-560,"width":250,"height":60},
		{"id":"877e28e2eb2e1de7","type":"text","text":"#### 1. Числовые типы данных\n**Типы**:\n- INTEGER (INT), SMALLINT, BIGINT\n- DECIMAL(p, s) - число с фиксированной точностью\n- FLOAT, REAL, DOUBLE PRECISION\n**Функции**:\n - ABS(x)\n - ROUND(x, n), CEIL(x), FLOOR(x)\n - MOD(x, y) : x % y\n - POWER(x, y) : x ** y\n \n#### 2. Строковые типы данных\n**Типы**:\n- CHAR(n) - фиксированная длина $n$\n- VARCHAR(n) - переменная длина (до $n$) символов\n- TEXT - неограниченная длина\n\n**Функции**:\n- LENGTH(s)\n- UPPER(s), LOWER(s)\n- SUBSTRING(s, start, length) - возвращает подстроку\n- TRIM(s) - удаляет пробелы в начале и конце\n- CONCAT(s1, s2, ...)\n- REPLACE(s, old, new)\n\n#### 3. Типы данных для дат и времени\n**Типы:**\n- DATE\n- TIME\n- DATETIME / TIMESTAMP\n- YEAR\n\n**Функции**:\n- CURRENT_DATE, CURRENT_TIME, NOW()\n- DATEADD(interval, value, date) - добавляет интервал к дате\n- DATEDIFF(date1, date2) - разница между двумя датами\n- EXTRACT(part FROM DATE)\n- DATE_FORMAT(date, format)\n- DAY, MONTH, YEAR, WEEK\n\n#### 4. Бинарные типы данных\nТипы\n- BINARY(n)\n\n#### 5. Логические типы данных\n- BOOLEAN","x":-1720,"y":-500,"width":600,"height":1540},
		{"id":"5f694633457615b2","type":"text","text":"### Ключи","x":-1120,"y":-560,"width":250,"height":60},
		{"id":"68c9eb0551eab6dc","type":"text","text":"Ключи используются для обеспечения целостности данных и установления связей между таблицами\n#### 1. Primary key (первичный ключ)\n- Уникально идентифицирует каждую запись в таблице\n- Гарантирует, что в таблице не будет дубликатов по этому значению\n- Не может содержать NULL значения\n\n#### 2. Foreign key (внешний ключ)\n- Устанавливает связь между таблицами\n- Обеспечивает ссылочную целостность: значение внешнего ключа должно соответствовать значению первичного ключа в связанной таблице\n- Может содержать NULL, если связь не обязательна\n\n```SQL\nCREATE TABLE Orders (\n\tOrderID INT PRIMARY KEY,\n\tOrderDate DATE NOT NULL,\n\tUserID INT,\n\tFOREIGN KEY (UserID) REFERENCES Users(UserID)\n);\n```\nКаждый заказ должен быть связан с пользователем\n\n```SQL\nCREATE TABLE Users (\n    UserID INT PRIMARY KEY,\n    UserName VARCHAR(50) NOT NULL\n);\n\nCREATE TABLE Orders (\n    OrderID INT PRIMARY KEY,\n    OrderDate DATE NOT NULL,\n    UserID INT,\n    FOREIGN KEY (UserID) REFERENCES Users(UserID)\n);\n\nSELECT \n    Orders.OrderID,\n    Orders.OrderDate,\n    Users.UserName\nFROM \n    Orders\nJOIN \n    Users ON Orders.UserID = Users.UserID;\n```\n#### 3. Candidate key\n- Столбец/набор столбцов, что могут быть использованы в качестве первичного ключа\n- Кандитатный ключдолжен быть уникальным и не содержать NULL\n- Из нескольких кандидатных ключей выбирается один, который становится первичным\n```SQL\nCREATE TABLE Employees (\n    EmployeeID INT UNIQUE,  -- Кандидатный ключ 1\n    Email VARCHAR(100) UNIQUE,  -- Кандидатный ключ 2\n    Name VARCHAR(50) NOT NULL\n);\n```\n","x":-1120,"y":-500,"width":560,"height":1680},
		{"id":"673be667a569a0ea","type":"text","text":"### Оконные функции\n\n```SQL\nSELECT \nfun\nOVER(\n\tPARTITION BY column\n\tORDER BY column_sort\n\tROWS/RANGE condition\n)\n```\n\nEx.\n```SQL\nSELECT date, name, rank, \nSUM(rank) OVER (PARTITION BY date ORDER BY date) AS 'sum'\nFROM orders \n```\n\n```SQL\nSELECT *, RANK() OVER (PARTITION BY orders.product_id ORDER BY orders.order_date)\nFROM orders\nJOIN customers USING(customer_id);\n\nSELECT *, min(order_date) OVER (PARTITION BY customer_id)\nFROM orders\nJOIN customers USING(customer_id); \n```\n\n","x":3480,"y":-500,"width":800,"height":520},
		{"id":"7ccb424a33b62a3f","type":"text","text":"### Числовые","x":-7120,"y":-341,"width":250,"height":60},
		{"id":"7a7b106041343d2b","type":"text","text":"### Дата и время","x":-7120,"y":-281,"width":250,"height":61},
		{"id":"eab9fa77ec7ef100","type":"text","text":"### Типы данных","x":-6995,"y":-490,"width":250,"height":60},
		{"id":"9b49404381802146","type":"text","text":"### Строковые","x":-6870,"y":-341,"width":250,"height":60},
		{"id":"b491f4548eabe3e3","type":"text","text":"### Логические","x":-6870,"y":-281,"width":250,"height":60},
		{"id":"c45a53489afbfc0b","type":"text","text":"### DDL (data definition language)\n\n- **CREATE**\n- **ALTER**\n- **DROP**\n- **TRUNCATE**","x":-6560,"y":-490,"width":400,"height":203},
		{"id":"cbb9febb8e6387a9","type":"text","text":"### Ключи и ограничения\n\n- **PRIMARY KEY**\n- **FOREIGN KEY**\n- **UNIQUE**\n- **CHECK**\n- **DEFAULT**","x":-6560,"y":-220,"width":400,"height":210},
		{"id":"0c387d6c594ecc54","type":"text","text":"### DCL (data control language)\n\n- **SELECT**\n- **INSERT**\n- **UPDATE**\n- **DELETE**","x":-6120,"y":-490,"width":480,"height":203},
		{"id":"bc61fed603dc52e3","type":"text","text":"# SQL","x":-5280,"y":-770,"width":250,"height":60},
		{"id":"808de60c5b71892e","type":"text","text":"### Операторы\n","x":-5280,"y":-490,"width":388,"height":60},
		{"id":"b434f0bd6d8cd515","type":"text","text":"### Сравнение\n- **=, <>, >, <, >=, <=**\n- **BETWEEN, IN, IS (NOT) NULL**","x":-5600,"y":-347,"width":370,"height":127},
		{"id":"a71e7175abfd6215","type":"text","text":"### Логические\n\n- **AND, OR, NOT**\n- **EXISTS, ANY, ALL**","x":-5200,"y":-347,"width":295,"height":127},
		{"id":"76c55dd302102fc5","type":"text","text":"### Арифметические","x":-4837,"y":-342,"width":270,"height":62},
		{"id":"9c2d576fe44c49b6","type":"text","text":"### Дата и время\n\n- **NOW()**\n- **CURRENT_DATE()**\n- **CURRENT_TIME()**\n- **DATE_ADD()**\n- **DATEDIFF()**\n- **EXTRACT()**","x":-5540,"y":320,"width":250,"height":297},
		{"id":"53e9c875423e4a34","type":"text","text":"### Строковые\n\n- **CONCAT()**\n- **SUBSTRING()**\n- **LENGTH()**\n- **UPPER()**\n- **LOWER()**\n- **TRIM()**\n- **LIKE()**","x":-6120,"y":320,"width":314,"height":297},
		{"id":"fcbfa34c818785b6","type":"text","text":"### Агрегатные","x":-4116,"y":-283,"width":250,"height":60},
		{"id":"0bc7cbce74bb2a55","type":"text","text":"### Подсчёт\n\n- **SUM()**\n- **AVG()**\n- **COUNT()**\n- **MIN()**\n- **MAX()**\n- **LENGTH()**","x":-4026,"y":-80,"width":250,"height":320},
		{"id":"242dc896c2130c16","type":"text","text":"### Оконные\n\n- **ROW_NUMBER()**\n- **RANK()**\n- **DENSE_RANK()**\n- **LEAD()**\n- **LAG()**\n- **PARTITION BY**\n- **OVER()**","x":-3690,"y":-283,"width":250,"height":390},
		{"id":"ac37a317b188d4ab","type":"text","text":"### Функции","x":-4530,"y":-492,"width":250,"height":60},
		{"id":"8540342e9efe3360","type":"text","text":"### Группировка и фильтрация\n- **DISTINCT**\n- **WHERE**\n- **GROUP BY**\n- **HAVING**\n- **LIMIT**","x":-4466,"y":-80,"width":372,"height":277},
		{"id":"f7e7a72cdc1c1f1b","type":"text","text":"### Соединения\n- **INNER JOIN**\n- **LEFT (RIGHT) JOIN**\n- **FULL JOIN**\n- **CROSS JOIN**\n- **SELF JOIN**","x":-3360,"y":-280,"width":355,"height":232},
		{"id":"feaf425696c06f4e","type":"text","text":"- **UNION**\n- **INTERSECT**\n- **SUBTRACT**","x":-4166,"y":-710,"width":280,"height":132},
		{"id":"f986ac172da33881","type":"text","text":"#### Структура оконной функции\nТри части:\n1) Сама функция (e.g. ROW_NUMBER(), SUM(), RANK())\n2) Оконная секция (определяет, как формируется окно):\n\t- PARTITION BY - разбивает данные на группы (как GROUP BY, но без сворачивания)\n\t- ORDER BY - сортирует строки внутри окна\n\t- ROWS или RANGE - определяет границы окна (e.g. \"все строки до текущей\")\n3) Алиас\n\n```SQL\nfunction() OVER (\n\t[PARTITION BY column1, column2, ...]\n\t[ORDER BY column3, column4, ...]\n\t[ROWS или RANGE ...]\n) AS alias\n```\n\n1\\. **ROW NUMBER()** - присваивает уникальный номер каждой строке внутри окна\n```SQL\nSELECT \n\tname, \n\tsalary, \n\tROW_NUMBER() OVER (ORDER BY salary DESC) AS row_number\nFROM employees;\n```\nresult:\nname    | salary | row_num\n--------+--------+--------\nAlice   | 5000   | 1\nBob     | 4000   | 2\nCharlie | 3000   | 3\n\n2\\. **RANK()** - присваивает ранг строкам, пропуская номера при совпадении значений\n```SQL\nSELECT\n\tname,\n\tsalary,Функция() OVER (\n\n\tRANK() OVER (ORDER BY salary DESC) AS rank\nFROM employees;\n```\nresult:\nname    | salary | rank\n--------+--------+------\nAlice   | 5000   | 1\nBob     | 4000   | 2\nCharlie | 4000   | 2\nDavid   | 3000   | 4\n\n3\\.  **SUM()**\n4\\. **PARTITION BY**\n```SQL\nSELECT\n\tdepartment,\n\tname,\n\tsalary,\n\tROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_row_num\nFROM employees;\n```\nresult:\ndepartment | name    | salary | dept_row_num\n-----------+---------+--------+-------------\nHR         | Alice   | 5000   | 1\nHR         | Bob     | 4000   | 2\nIT         | Charlie | 3000   | 1","x":3480,"y":70,"width":800,"height":1570},
		{"id":"4b96118dce02cd9b","type":"text","text":"### Ещё примеры\n\n1\\. **ROW_NUMBER()** - присваивает уникальный номер каждой строке в рамках окна\n```SQL\nSELECT \n\torder_id,\n\tcustomer_name,\n\tproduct_name,\n\tprice,\n\tROW_NUMBER() OVER (ORDER BY price DESC) AS row_numb\nFROM orders;\n```\n\n**Результат:**\n\n| order_id | customer_name | product_name | price   | row_num |\n| -------- | ------------- | ------------ | ------- | ------- |\n| 1        | Alice         | Laptop       | 1200.00 | 1       |\n| 2        | Bob           | Smartphone   | 800.00  | 2       |\n| 6        | Bob           | Camera       | 700.00  | 3       |\n| 3        | Charlie       | Tablet       | 500.00  | 4       |\n| 5        | David         | Smartwatch   | 300.00  | 5       |\n| 8        | Charlie       | Monitor      | 250.00  | 6       |\n| 7        | Eve           | Printer      | 200.00  | 7       |\n| 4        | Alice         | Headphones   | 150.00  | 8       |\n| 11       | Frank         | Speaker      | 120.00  | 9       |\n| 9        | Alice         | Keyboard     | 100.00  | 10      |\n| 14       | Charlie       | Webcam       | 90.00   | 11      |\n| 12       | Eve           | External HDD | 80.00   | 12      |\n| 15       | Alice         | Microphone   | 70.00   | 13      |\n| 10       | David         | Mouse        | 50.00   | 14      |\n| 13       | Bob           | USB Drive    | 20.00   | 15      |\n\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    ROW_NUMBER() OVER (PARTITION BY customer_name ORDER BY price DESC) AS row_num\nFROM orders;\n```\n\n**Результат:**\n\n|order_id|customer_name|product_name|price|row_num|\n|---|---|---|---|---|\n|1|Alice|Laptop|1200.00|1|\n|4|Alice|Headphones|150.00|2|\n|9|Alice|Keyboard|100.00|3|\n|15|Alice|Microphone|70.00|4|\n|2|Bob|Smartphone|800.00|1|\n|6|Bob|Camera|700.00|2|\n|13|Bob|USB Drive|20.00|3|\n|3|Charlie|Tablet|500.00|1|\n|8|Charlie|Monitor|250.00|2|\n|14|Charlie|Webcam|90.00|3|\n|5|David|Smartwatch|300.00|1|\n|10|David|Mouse|50.00|2|\n|7|Eve|Printer|200.00|1|\n|12|Eve|External HDD|80.00|2|\n|11|Frank|Speaker|120.00|1|","x":4320,"y":-500,"width":840,"height":1660},
		{"id":"601e054f3d5d39a4","type":"text","text":"**2\\. RANK()** - присваивает рнг строкам, пропуская номера при совпадении значений\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    RANK() OVER (ORDER BY price DESC) as rank\nFROM orders;\n```\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    RANK() OVER PARTITION BY (customer_name ORDER BY price DESC)\nFROM orders;\n```\n\n**Результат:**\n\n|order_id|customer_name|product_name|price|rank|\n|---|---|---|---|---|\n|1|Alice|Laptop|1200.00|1|\n|4|Alice|Headphones|150.00|2|\n|9|Alice|Keyboard|100.00|3|\n|15|Alice|Microphone|70.00|4|\n|2|Bob|Smartphone|800.00|1|\n|6|Bob|Camera|700.00|2|\n|13|Bob|USB Drive|20.00|3|\n|3|Charlie|Tablet|500.00|1|\n|8|Charlie|Monitor|250.00|2|\n|14|Charlie|Webcam|90.00|3|\n|5|David|Smartwatch|300.00|1|\n|10|David|Mouse|50.00|2|\n|7|Eve|Printer|200.00|1|\n|12|Eve|External HDD|80.00|2|\n|11|Frank|Speaker|120.00|1|","x":4320,"y":1200,"width":840,"height":1040},
		{"id":"62138e1cc10be28b","type":"text","text":"**3\\. LEAD()** возвращает значение из следующей строки в рамках окна\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    LEAD(price) OVER (ORDER BY order_id) AS next_price\nFROM orders;\n```\n**Результат:**\n\n|order_id|customer_name|product_name|price|next_price|\n|---|---|---|---|---|\n|1|Alice|Laptop|1200.00|800.00|\n|2|Bob|Smartphone|800.00|500.00|\n|3|Charlie|Tablet|500.00|150.00|\n|4|Alice|Headphones|150.00|300.00|\n|5|David|Smartwatch|300.00|700.00|\n|6|Bob|Camera|700.00|200.00|\n|7|Eve|Printer|200.00|250.00|\n|8|Charlie|Monitor|250.00|100.00|\n|9|Alice|Keyboard|100.00|50.00|\n|10|David|Mouse|50.00|120.00|\n|11|Frank|Speaker|120.00|80.00|\n|12|Eve|External HDD|80.00|20.00|\n|13|Bob|USB Drive|20.00|90.00|\n|14|Charlie|Webcam|90.00|70.00|\n|15|Alice|Microphone|70.00|NULL|\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    LEAD(price) OVER (PARTITION BY customer_name ORDER BY order_id) AS next_price\nFROM orders;\n```\n**Результат:**\n\n|order_id|customer_name|product_name|price|next_price|\n|---|---|---|---|---|\n|1|Alice|Laptop|1200.00|150.00|\n|4|Alice|Headphones|150.00|100.00|\n|9|Alice|Keyboard|100.00|70.00|\n|15|Alice|Microphone|70.00|NULL|\n|2|Bob|Smartphone|800.00|700.00|\n|6|Bob|Camera|700.00|20.00|\n|13|Bob|USB Drive|20.00|NULL|\n|3|Charlie|Tablet|500.00|250.00|\n|8|Charlie|Monitor|250.00|90.00|\n|14|Charlie|Webcam|90.00|NULL|\n|5|David|Smartwatch|300.00|50.00|\n|10|David|Mouse|50.00|NULL|\n|7|Eve|Printer|200.00|80.00|\n|12|Eve|External HDD|80.00|NULL|\n|11|Frank|Speaker|120.00|NULL|\n","x":5200,"y":-500,"width":840,"height":1540},
		{"id":"4bb13715a7f37577","type":"text","text":"**4. LAG()** - возвращает значение из предыдущей строки в рамках окна\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    LAG(price) OVER (ORDER BY order_id) AS previous_price\nFROM orders;\n```\n**Результат:**\n\n|order_id|customer_name|product_name|price|previous_price|\n|---|---|---|---|---|\n|1|Alice|Laptop|1200.00|NULL|\n|2|Bob|Smartphone|800.00|1200.00|\n|3|Charlie|Tablet|500.00|800.00|\n|4|Alice|Headphones|150.00|500.00|\n|5|David|Smartwatch|300.00|150.00|\n|6|Bob|Camera|700.00|300.00|\n|7|Eve|Printer|200.00|700.00|\n|8|Charlie|Monitor|250.00|200.00|\n|9|Alice|Keyboard|100.00|250.00|\n|10|David|Mouse|50.00|100.00|\n|11|Frank|Speaker|120.00|50.00|\n|12|Eve|External HDD|80.00|120.00|\n|13|Bob|USB Drive|20.00|80.00|\n|14|Charlie|Webcam|90.00|20.00|\n|15|Alice|Microphone|70.00|90.00|\n\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    LAG(price) OVER (PARTITION BY customer_name ORDER BY order_id) AS previous_price\nFROM orders;\n```\n\n**Результат:**\n\n| order_id | customer_name | product_name | price   | previous_price |\n| -------- | ------------- | ------------ | ------- | -------------- |\n| 1        | Alice         | Laptop       | 1200.00 | NULL           |\n| 4        | Alice         | Headphones   | 150.00  | 1200.00        |\n| 9        | Alice         | Keyboard     | 100.00  | 150.00         |\n| 15       | Alice         | Microphone   | 70.00   | 100.00         |\n| 2        | Bob           | Smartphone   | 800.00  | NULL           |\n| 6        | Bob           | Camera       | 700.00  | 800.00         |\n| 13       | Bob           | USB Drive    | 20.00   | 700.00         |\n| 3        | Charlie       | Tablet       | 500.00  | NULL           |\n| 8        | Charlie       | Monitor      | 250.00  | 500.00         |\n| 14       | Charlie       | Webcam       | 90.00   | 250.00         |\n| 5        | David         | Smartwatch   | 300.00  | NULL           |\n| 10       | David         | Mouse        | 50.00   | 300.00         |\n| 7        | Eve           | Printer      | 200.00  | NULL           |\n| 12       | Eve           | External HDD | 80.00   | 200.00         |\n| 11       | Frank         | Speaker      | 120.00  | NULL           |\n`LAG(price, 2, 0)` вернет цену из строки, отстоящей на 2 позиции назад, а если такой строки нет, то вернет `0`.","x":5200,"y":1080,"width":840,"height":1680},
		{"id":"87a41b521b3edc16","type":"text","text":"1\\.`ROWS` определяет физические границы окна в строках. Например:\n- `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` — от начала до текущей строки.\n- `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING` — предыдущая, текущая и следующая строки.\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    SUM(price) OVER (\n        ORDER BY order_id\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cumulative_sum\nFROM orders;\n```\n\n2\\. `RANGE` определяет логические границы окна на основе значений столбца. Например:\n\n- `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` — от начала до текущей строки, учитывая значения.\n    \n- `RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND CURRENT ROW` — для временных данных.\n\n```SQL\nSELECT \n    order_id,\n    customer_name,\n    product_name,\n    price,\n    SUM(price) OVER (\n        ORDER BY price\n        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cumulative_sum\nFROM orders;\n```","x":3480,"y":1680,"width":800,"height":900,"color":"2"},
		{"id":"3f3a3b6fe78784e1","type":"text","text":"","x":-6811,"y":2878,"width":911,"height":822},
		{"id":"5fabfb8927b62dbb","type":"text","text":"### Admin stuff\n\n| Операция                  | Пример запроса                                                          |\n| ------------------------- | ----------------------------------------------------------------------- |\n| **Создать базу данных**   | `CREATE DATABASE mydb;`                                                 |\n| **Удалить базу данных**   | `DROP DATABASE mydb;`                                                   |\n| **Создать таблицу**       | `CREATE TABLE users (id INT PRIMARY KEY, name TEXT);`                   |\n| **Удалить таблицу**       | `DROP TABLE users;`                                                     |\n| **Переименовать таблицу** | `ALTER TABLE old_name RENAME TO new_name;`                              |\n| **Добавить колонку**      | `ALTER TABLE users ADD COLUMN email TEXT;`                              |\n| **Удалить колонку**       | `ALTER TABLE users DROP COLUMN email;` _(не во всех СУБД)_              |\n| **Изменить тип колонки**  | `ALTER TABLE users ALTER COLUMN name TYPE VARCHAR(100);` _(PostgreSQL)_ |\n| **Создать индекс**        | `CREATE INDEX idx_users_name ON users(name);`                           |\n| **Удалить индекс**        | `DROP INDEX idx_users_name;` _(или через ALTER TABLE в SQLite)_         |\n\n### Стандартные SQL-метаданные (через `INFORMATION_SCHEMA`)\n\n| Описание           | Пример запроса                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------- |\n| Список всех таблиц | `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';`           |\n| Структура таблицы  | `SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';` |\n| Список баз данных  | `SELECT datname FROM pg_database;` _(PostgreSQL)_                                           |\n| Список схем        | `SELECT schema_name FROM information_schema.schemata;`                                      |\n\nSQLite:\n```sql\n-- Список таблиц\nSELECT name FROM sqlite_master WHERE type='table';\n\n-- Структура таблицы\nPRAGMA table_info(users);\n```\nMySQL\n```sql\nSHOW DATABASES;\nSHOW TABLES;\nDESCRIBE users;\nSHOW COLUMNS FROM users;\n```\n\n**Администрирование доступа**\n\n|Операция|Пример запроса|\n|---|---|\n|Создать пользователя|`CREATE USER 'alice'@'localhost' IDENTIFIED BY 'pass';`|\n|Дать права|`GRANT SELECT, INSERT ON mydb.* TO 'alice'@'localhost';`|\n|Отозвать права|`REVOKE INSERT ON mydb.* FROM 'alice'@'localhost';`|\n|Удалить пользователя|`DROP USER 'alice'@'localhost';`|\n","x":-8000,"y":-191,"width":775,"height":1617},
		{"id":"2a20648d4b96ef48","type":"text","text":"# From LeetCode\n\n## SELECTS\n\n**ISNULL()**\nISNULL(referee_id) OR referee_id != 2;\n\n**DISTINCT**\nSELECT DISTINCT author_id AS id \nFROM Views\nWHERE author_id = viewer_id\nORDER BY id ASC;\n\n**LENGTH()**\n\n## JOINS\n\n**USING()**\nSELECT unique_id, name\nFROM Employees \nLEFT JOIN EmployeeUNI USING(id);\n\n**COUNT()**\nSELECT customer_id, COUNT(customer_id) AS count_no_trans\nFROM Visits\nLEFT JOIN Transactions ON Visits.visit_id = Transactions.visit_id\nWHERE ISNULL(transaction_id)\nGROUP BY customer_id;\n\n**SELF JOIN**\nSELECT *\nFROM Weather AS W1\nJOIN Weather AS W2 ON DATE_PART('day', W1.recordDate) - DATE_PART('day', W2.recordDate) = 1;\n\n**ROUND(), AVG()**\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_time\nFROM\n    (SELECT \\* FROM Activity\n    WHERE activity_type = 'start') AS A1\nJOIN \n    (SELECT \\* FROM Activity\n    WHERE activity_type = 'end') AS A2\nON A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id\nGROUP BY A1.machine_id;\n\nТо же самое, но с **WITH**\nWITH starts AS (\n\tSELECT * FROM Activity WHERE activity_type = 'start'\n),\nends AS (\n\tSELECT * FROM Activity WHERE activity_type = 'end'\n)\nSELECT \n\tstarts.machine_id,\n\t ROUND(AVG(ends.timestamp - starts.timestamp), 3) AS processing_time\nFROM starts\nJOIN ends\n\tON starts.machine_id = ends.machine_id AND starts.process_id = ends.process_id\nGROUP BY starts.macine_id;\n","x":-8480,"y":1620,"width":940,"height":1660},
		{"id":"4d69bdc11475dec0","type":"text","text":"### PostgreSQL example\n\nCREATE TABLE Weather (\n  id INT PRIMARY KEY,\n  recordDate DATE,\n  temperature INT\n);\n\nINSERT INTO Weather (id, recordDate, temperature) \nVALUES \n  (1, '2015-01-01', 10),\n  (2, '2015-01-02', 25),\n  (3, '2015-01-03', 20),\n  (4, '2015-01-04', 30)\nON CONFLICT(id) DO NOTHING;\n","x":-9620,"y":2680,"width":980,"height":502},
		{"id":"e115ece8e83ca1d8","type":"text","text":"\n```\nVisits\n+----------+-------------+\n| visit_id | customer_id |\n+----------+-------------+\n| 1        | 23          |\n| 2        | 9           |\n| 4        | 30          |\n| 5        | 54          |\n| 6        | 96          |\n| 7        | 54          |\n| 8        | 54          |\n+----------+-------------+\nTransactions\n+----------------+----------+--------+\n| transaction_id | visit_id | amount |\n+----------------+----------+--------+\n| 2              | 5        | 310    |\n| 3              | 5        | 300    |\n| 9              | 5        | 200    |\n| 12             | 1        | 910    |\n| 13             | 2        | 970    |\n+----------------+----------+--------+\n\nSELECT visit_id, customer_id, transaction_id FROM Visits\nLEFT JOIN Transactions USING(visits_id);\n\n+----------+-------------+----------------+\n| visit_id | customer_id | transaction_id |\n+----------+-------------+----------------+\n| 1        | 23          | 12\n| 2        | 9           | 13\n| 4        | 30          | NULL\n| 5        | 54          | 2\n| 5        | 54          | 3\n| 5        | 54          | 9\n| 6        | 96          | NULL \n| 7        | 54          | NULL\n| 8        | 54          | NULL\n+----------+-------------+\n```","x":-9300,"y":1600,"width":620,"height":1020},
		{"id":"9b29d6fa08dcb3fb","type":"text","text":"## 📚 1. Числовые типы данных\n\n|Тип|Размер|Диапазон (примерно)|Назначение|\n|---|---|---|---|\n|`SMALLINT`|2 байта|-32 768 до 32 767|Маленькие целые|\n|`INTEGER` / `INT`|4 байта|-2 млрд до 2 млрд|Стандартный целый|\n|`BIGINT`|8 байт|±9 × 10¹⁸|Очень большие целые|\n|`SERIAL`|4 байта|как `INTEGER`, автоинкремент|Для автоинкрементных ID|\n|`BIGSERIAL`|8 байт|как `BIGINT`, автоинкремент|То же, но больше|\n|`DECIMAL(p,s)` / `NUMERIC(p,s)`|вар.|фикс. точность|Денежные суммы, точные вычисления|\n|`REAL`|4 байта|±1.18×10⁻³⁸ до 3.4×10³⁸|Числа с плавающей точкой (прибл.)|\n|`DOUBLE PRECISION`|8 байт|±2.23×10⁻³⁰⁸ до 1.8×10³⁰⁸|Более точные числа с плавающей точкой|\n\n> ⚠️ `REAL` и `DOUBLE PRECISION` — быстро, но **могут терять точность**. Для денег — всегда `NUMERIC`.\n\n---\n\n## 🔤 2. Строковые типы данных\n\n|Тип|Назначение|\n|---|---|\n|`CHAR(n)`|Фиксированная длина (всегда `n` символов)|\n|`VARCHAR(n)`|Переменная длина, максимум `n` символов|\n|`TEXT`|Без ограничения длины (до 1 ГБ)|\n\n> 💡 В PostgreSQL нет разницы в производительности между `VARCHAR(n)` и `TEXT`. Обычно предпочтителен `TEXT`.\n\n---\n\n## 📅 3. Дата и время\n\n|Тип|Назначение|\n|---|---|\n|`DATE`|Только дата (`YYYY-MM-DD`)|\n|`TIME`|Только время (`HH:MM:SS`)|\n|`TIMESTAMP`|Дата + время без часового пояса|\n|`TIMESTAMPTZ`|С часовым поясом (timezone-aware)|\n|`INTERVAL`|Промежуток времени (`3 days`, `2 hours`, ...)|\n\n> 💡 `TIMESTAMPTZ` — предпочтителен для логов и глобальных приложений.\n\n---\n\n## ✅ 4. Логические\n\n|Тип|Значения|\n|---|---|\n|`BOOLEAN`|`TRUE`, `FALSE`, `NULL`|\n\n> 💡 Поддерживается прямой синтаксис: `WHERE active IS TRUE`\n\n---\n\n## 📦 5. UUID\n\n|Тип|Назначение|\n|---|---|\n|`UUID`|Уникальные идентификаторы (`uuid4`)|\n\n> 💡 PostgreSQL умеет генерировать UUID с помощью расширения `uuid-ossp`.\n\n---\n\n## 🧠 6. JSON и структуры\n\n|Тип|Назначение|\n|---|---|\n|`JSON`|Хранение строки, проверяется валидность|\n|`JSONB`|Бинарный формат, **лучше для запросов**|\n|`ARRAY`|Массив значений|\n|`HSTORE`|Пары ключ-значение (как `dict`, строка-строка)|\n\n> 💡 `JSONB` поддерживает индексы, `ARRAY` — полезен для тэгов и флагов.\n\n---\n\n## 🗺️ 7. Географические и специализированные (примеры)\n\n|Тип|Назначение|\n|---|---|\n|`POINT`|Гео-координата (`x, y`)|\n|`LINE`, `CIRCLE`|Геометрия|\n|`CIDR`, `INET`|IP-адреса|\n|`BIT(n)`|Битовые значения|\n|`BYTEA`|Двоичные данные (например, файлы)|\n|`ENUM`|Ограниченное множество значений|\n\n---\n\n## 📌 Резюме: какой тип когда использовать?\n\n|Задача|Тип данных|\n|---|---|\n|Целые значения|`INTEGER`, `BIGINT`|\n|Автоинкремент ID|`SERIAL`, `BIGSERIAL`|\n|Деньги|`NUMERIC(12,2)`|\n|Длинный текст|`TEXT`|\n|Время|`TIMESTAMPTZ`|\n|Да/Нет|`BOOLEAN`|\n|Списки значений|`ARRAY`|\n|JSON-структуры|`JSONB`|\n|Уникальный ключ|`UUID`|","x":-300,"y":-4200,"width":1340,"height":2720},
		{"id":"0782548d92d68295","type":"text","text":"0\\. **WITH**\n7\\. **SELECT** (8\\. **DISTINCT**)\n1\\. **FROM**\n3\\. **JOIN** 2\\. **ON** | **UNION** \n4\\. **WHERE**\n5\\. **GROUP BY**\n6\\. **HAVING**\n9\\. **ORDER BY**\n10\\. **LIMIT | OFFSET**\n\n```sql\nWITH cte AS (\n  SELECT * FROM Sales WHERE amount > 100\n)\nSELECT region, COUNT(*) AS big_sales\nFROM cte\nWHERE region IS NOT NULL\nGROUP BY region\nHAVING COUNT(*) > 5\nORDER BY big_sales DESC;\n```","x":-300,"y":-1440,"width":480,"height":600},
		{"id":"8ab0007c92b2c555","type":"text","text":"**Операторы по типам**\n1\\. **Арифметические**\n- +, -, \\*, /, %\n- ROUND, CEIL, FLOOR, ABS, POWER, SQRT, RANDOM, TRUNC\n\n2\\. **Строковые**\n- LIKE / ILIKE (wildcards %, \\_)\n- LENGTH, LOWER, UPPER, INITCAP, TRIM, SUBSTRING, REPLACE, POSITION, LEFT, RIGHT, \n\n3\\. **Дата и время**\n- +, -, AGE(date1, date2)\n- NOW(), CURRENT_DATE, CURRENT_TIME, DATE_TRUNC, EXTRACT, TO_CHAR, TO_TIMESTAMP\n\n4\\. **Логика**\n- =, !=, <>, >, <, >=, <=, IS NULL, BETWEEN a AND b, IN(v_1, ...), NOT, AND, OR\n\n5\\. **Агрегатные функции**\n- COUNT(\\*), COUNT(col), SUM(col), AVG, MIN, MAX, STRING_AGG(col, sep)\n\n6\\. **Оконные функции**\nПрименяются с OVER() и не сжимают число строк\n- ROW_NUMBER(), RANK(), DENSE_RANK(), NTILE(), LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE(), SUM(...) OVER (...)\n\n7\\. **Работа с NULL**\nCOALESCE(a, b, ...)\nNULLIF(a, b)","x":220,"y":-1440,"width":1060,"height":800},
		{"id":"17dc833d1206f253","type":"text","text":"### Window functions\n```sql\nFUNCTION() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE ...)\n```\nOVER - makes a function a window function\nPARTITION BY - similarly to GROUP BY, but instead of collapsing rows, it divides data into groups for calc purposes\nORDER BY determines the sequence for calculations, which matters greatly for functions like ROW_NUMBER, RANK, running totals or moving averages\n\nМаксимальная зп в рамках департамента (если внутри скобок пусто, то по всем работникам)\n```sql \nSELECT e.*,\nMAX(salary) OVER(PARTITION BY dept_name) AS max_salary\nFROM employee e;\n```\nROW_NUMBER\nНомер строки в рамках департамента (пусто внутри over => по таблице)\n```sql\nSELECT *\nROW_NUMBER() OVER(PARTITION BY dept_name) AS rn\nFROM employee;\n```\n\n```sql\nSELECT *\nFROM (\n  SELECT *, \n  ROW_NUMBER() OVER(PARTITION BY deptId) AS rn\n  FROM EMPLOYEE\n) sub\nWHERE rn < 3;\n```\nRANK, DENSE_RANK (RANK скипает, DENSE_RANK нет)\nРанжируем зп по убыванию\n```sql\nSELECT *,\nRANK() OVER(PARTITION BY deptId ORDER BY salary DESC) AS rnk\nFROM EMPLOYEE;\n```\n","x":-9620,"y":3320,"width":980,"height":1000},
		{"id":"605dcb9febdd8ffd","x":-9620,"y":4400,"width":980,"height":520,"type":"text","text":"### Indices\n```sql\nCREATE INDEX users_index_email ON users(email);\nSELECT * FROM users WHERE email = 'test@example.com'\n```\n\nУскорить WHERE по частому фильтру, ускорить JOIN по внешнему ключу"},
		{"id":"b3aeac8c3f04b60e","x":-10260,"y":4040,"width":588,"height":458,"type":"text","text":"## 🎯 Ключевые цели `FOREIGN KEY`:\n\n|Цель|Пример|\n|---|---|\n|Обеспечить **связь таблиц**|заказ → пользователь|\n|Обеспечить **целостность**|нельзя вставить заказ с несуществующим `user_id`|\n|Помочь при **JOIN'ах**|`JOIN` по `user_id` будет корректным и быстрым|\n\n---"}
	],
	"edges":[
		{"id":"259e22f3ed535e70","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"eab9fa77ec7ef100","toSide":"top"},
		{"id":"f153e1583b1a46b0","fromNode":"eab9fa77ec7ef100","fromSide":"bottom","toNode":"7ccb424a33b62a3f","toSide":"top"},
		{"id":"144c04a7695ce927","fromNode":"eab9fa77ec7ef100","fromSide":"bottom","toNode":"9b49404381802146","toSide":"top"},
		{"id":"a5ef14e44eecd97a","fromNode":"eab9fa77ec7ef100","fromSide":"bottom","toNode":"7a7b106041343d2b","toSide":"top"},
		{"id":"9bff5352dc9ff2f2","fromNode":"eab9fa77ec7ef100","fromSide":"bottom","toNode":"b491f4548eabe3e3","toSide":"top"},
		{"id":"41293bd29ca536bf","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"c45a53489afbfc0b","toSide":"top"},
		{"id":"ce58e423a0d30b6f","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"0c387d6c594ecc54","toSide":"top"},
		{"id":"18ecb54fbe4da983","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"ac37a317b188d4ab","toSide":"top"},
		{"id":"042b3145c697d8fb","fromNode":"ac37a317b188d4ab","fromSide":"bottom","toNode":"fcbfa34c818785b6","toSide":"top"},
		{"id":"2cc63495cb668b1f","fromNode":"fcbfa34c818785b6","fromSide":"bottom","toNode":"0bc7cbce74bb2a55","toSide":"top"},
		{"id":"d82c50c483fd734a","fromNode":"fcbfa34c818785b6","fromSide":"bottom","toNode":"8540342e9efe3360","toSide":"top"},
		{"id":"6007ab94378dfdd7","fromNode":"ac37a317b188d4ab","fromSide":"bottom","toNode":"53e9c875423e4a34","toSide":"top"},
		{"id":"118d397cc0373323","fromNode":"ac37a317b188d4ab","fromSide":"bottom","toNode":"9c2d576fe44c49b6","toSide":"top"},
		{"id":"ef8b8739e33d4305","fromNode":"ac37a317b188d4ab","fromSide":"right","toNode":"242dc896c2130c16","toSide":"top"},
		{"id":"66ca8d800849b348","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"cbb9febb8e6387a9","toSide":"top"},
		{"id":"793cbd94a4f846ec","fromNode":"7a7b106041343d2b","fromSide":"top","toNode":"7ccb424a33b62a3f","toSide":"bottom"},
		{"id":"fc9a55cbe24d1a2e","fromNode":"9b49404381802146","fromSide":"bottom","toNode":"53e9c875423e4a34","toSide":"top"},
		{"id":"dab68e48eba7fc61","fromNode":"7a7b106041343d2b","fromSide":"bottom","toNode":"9c2d576fe44c49b6","toSide":"top"},
		{"id":"9fed82149effddce","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"808de60c5b71892e","toSide":"top"},
		{"id":"c69e681e16947d9a","fromNode":"808de60c5b71892e","fromSide":"bottom","toNode":"b434f0bd6d8cd515","toSide":"top"},
		{"id":"a00ecac73e8bf67c","fromNode":"808de60c5b71892e","fromSide":"bottom","toNode":"a71e7175abfd6215","toSide":"top"},
		{"id":"3c1a4e145a8b599c","fromNode":"808de60c5b71892e","fromSide":"bottom","toNode":"76c55dd302102fc5","toSide":"top"},
		{"id":"bf22096d04c45759","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"f7e7a72cdc1c1f1b","toSide":"top"},
		{"id":"501de9ad1aa8d96b","fromNode":"bc61fed603dc52e3","fromSide":"bottom","toNode":"feaf425696c06f4e","toSide":"top"},
		{"id":"7c739d54bd0a54f9","fromNode":"673be667a569a0ea","fromSide":"bottom","toNode":"f986ac172da33881","toSide":"top"},
		{"id":"93173faa90d091f0","fromNode":"f986ac172da33881","fromSide":"right","toNode":"4b96118dce02cd9b","toSide":"left"},
		{"id":"c5a28f136133748d","fromNode":"4b96118dce02cd9b","fromSide":"bottom","toNode":"601e054f3d5d39a4","toSide":"top"},
		{"id":"7eaf4cf31292de8b","fromNode":"601e054f3d5d39a4","fromSide":"bottom","toNode":"62138e1cc10be28b","toSide":"top"},
		{"id":"99875f1537156a80","fromNode":"62138e1cc10be28b","fromSide":"bottom","toNode":"4bb13715a7f37577","toSide":"top"},
		{"id":"577b556e61ac95b0","fromNode":"f986ac172da33881","fromSide":"bottom","toNode":"87a41b521b3edc16","toSide":"top"},
		{"id":"9d5d23b15736b417","fromNode":"e115ece8e83ca1d8","fromSide":"right","toNode":"2a20648d4b96ef48","toSide":"left"},
		{"id":"bb50a426233bfb63","fromNode":"4d69bdc11475dec0","fromSide":"right","toNode":"2a20648d4b96ef48","toSide":"left"}
	]
}