{
	"nodes":[
		{"id":"69fcdb7a30a0ea65","type":"text","text":"#### 1. Contains Duplicate (easy)\n**Idea**: Use a set to store elements\n\n**Example 1**:\n```python\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n```\n**Example 2**:\n```python\nInput: nums = [1, 2, 3, 4]\n\nOutput: false\n```\n**Complexity**: $O(n)$ time, $O(n)$ space\n\n```python\nclass Solution:\n\tdef hasDuplicate(self, nums: List[int]) -> bool:\n\t\ts = set()\n\tfor n in nums:\n\t\tif n not in s:\n\t\t\ts.add(n)\n\t\telse:\n\t\t\treturn True\n\treturn False\n```\n\n","x":-1632,"y":-1040,"width":720,"height":680,"color":"4"},
		{"id":"4c19af82c647267a","type":"text","text":"#### 4. Group Anagrams (medium)\n**Idea**: Word (of 26 symb) -> tuple; dict (tuple -> list of words)\n\n**Example 1:**\n```python\nInput: strs = [\"act\",\"pots\",\"tops\",\"cat\",\"stop\",\"hat\"]\n\nOutput: [[\"hat\"],[\"act\", \"cat\"],[\"stop\", \"pots\", \"tops\"]]\n```\n\n**Complexity**: $O(n \\cdot \\textrm{max\\_len})$ time, $O(n)$ space\n\n```python\nclass Solution:\n\tdef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n\td = {}\n\tfor s in strs:\n\t\tcount_arr = [0] * 26\n\t\tfor letter in s:\n\t\t\tcount_arr[ord(letter) - ord('a')] += 1\n\t\t\tcount_tuple = tuple(count_arr)\n\t\t\td[count_tuple] = d.get(count_tuple, []) + [s]\n\treturn list(d.values())\n```\n\n**Note**:\n- ord(char) for index of character in ASCII\n- tuples as keys of a hashmap","x":-912,"y":-1040,"width":873,"height":660,"color":"4"},
		{"id":"153cb32d025e9f16","type":"text","text":"### Arrays & Hashing\n**Ideas**:\n- Use set, dict (element -> id), dict (element -> number of occurrences), dict (tuple -> list)\n- arr[j] + arr[i] = target <=> (target - arr)[j] in set(arr) \n- Prefix/suffix arrays\n- Bucket sort (count sort)","x":-1632,"y":-1280,"width":1593,"height":240,"color":"6"},
		{"id":"81dafc93b0321135","type":"text","text":"#### Notes\n25.01: a lot of mistakes\n- Longest Repeating Character Replacement\n- Trees 1-3\n- DP-1 Decode Ways","x":3009,"y":-1840,"width":511,"height":240},
		{"id":"f86844ee3dccd104","type":"text","text":"#### Remove node from end of linked list (medium)\n\n**Note**: edgecase - node is head","x":370,"y":-1703,"width":447,"height":196},
		{"id":"ce50583c334a1ae5","type":"text","text":"### Linked lists","x":370,"y":-1763,"width":250,"height":60},
		{"id":"f047ce21cebc0b3d","type":"text","text":"### Greedy","x":1280,"y":-2000,"width":250,"height":60},
		{"id":"a96e0deb481cb747","type":"text","text":"#### Maximum subarray (medium)\n**Note**:\n- bad solution, rewrite","x":1280,"y":-1940,"width":371,"height":207},
		{"id":"ae71ccf27a746471","type":"text","text":"\n### Data structures\n\n#### Array\n- Build $O(n)$. $X^n \\rightarrow \\textrm{Arr}_n(X)$\n- Insert $O(n)$. $\\textrm{Arrays}(X) \\times X \\times \\mathbb{N}$\n- Read $O(1)$\n- Search $O(n)$\n- Pop $O(1)$\n- Remove (in general case) $O(n)$\n**Memory**: $O(n)$\n**Iterating**: by index in a known order\n#### Tuple\nSame as the array, but immutable, so can be used as a dictionary key\n#### Set\n- Build $O(n)$\n- Insert $O(1)$\n- Search $O(1)$\n- Remove $O(1)$\n**Memory**: $O(n)$\n**Iterating**: by element in an unknown order","x":-1632,"y":-3140,"width":892,"height":680},
		{"id":"edb2e45b2e5a2a29","type":"text","text":"## Algorithms and Data structures","x":-1632,"y":-3200,"width":446,"height":60},
		{"id":"f24b939efc626c1f","type":"text","text":"**MergeSort**: $T(n) = 2*T(n/2) + n = n\\textrm{log}_2n$","x":-680,"y":-3148,"width":478,"height":108},
		{"id":"6828173c4be6bcc9","type":"text","text":"#### 2. Valid Anagram (easy)\n**Idea**: Word (of 26 symb) -> tuple/dict\n\n**Example 1:**\n```python\nInput: s = \"racecar\", t = \"carrace\"\n\nOutput: true\n```\n**Example 2:**\n```python\nInput: s = \"jar\", t = \"jam\"\n\nOutput: false\n```\n**Complexity**: $O(n + m)$ time, $O(1)$ space \n\n```python\nclass Solution:\n\tdef isAnagram(self, s: str, t: str) -> bool:\n\t\td_s = {}\n\t\td_t = {}\n\t\tfor letter in s:\n\t\t\td_s[letter] = d_s.get(letter, 0) + 1\n\t\tfor letter in t:\n\t\t\td_t[letter] = d_t.get(letter, 0) + 1\n\t\treturn d_s == d_t\n```\n\n**Note**:\n- $O(1)$ space because the number of letters used in strings is fixed in the problem statement\n- Use d.get for prettier code","x":-1632,"y":-360,"width":720,"height":820,"color":"4"},
		{"id":"08f7dabd09700350","type":"text","text":"#### 3. Two Sum (easy)\n\n**Idea**: target - nums_j = nums_i. Calculate target - nums, iterate over dict (nums -> id) and check if diff = (target - nums_i) in dict (nums -> id) and dict[diff] != id\n\n**Example 1:**\n\n```python\nInput: \nnums = [3,4,5,6], target = 7\n\nOutput: [0,1]\n```\n\n**Example 2:**\n\n```python\nInput: nums = [4,5,6], target = 10\n\nOutput: [0,2]\n```\n\n**Complexity:** $O(n)$ time, $O(n)$ space\n\n```python\nclass Solution:\n\tdef twoSum(self, nums: List[int], target: int) -> List[int]:\n\t\td_nums = {nums[i]: i for i in range(len(nums))}\n\t\tfor i in range(len(nums)):\n\t\t\tdiff = target - nums[i]\n\t\t\tif diff in d_nums and i != d_nums[diff]:\n\t\t\t\treturn [i, d_nums[diff]]\n```\n\n**Note**:\n- We need a hashmap nums -> id here\n- **!!!** i $\\neq$ j","x":-1632,"y":460,"width":720,"height":780,"color":"4"},
		{"id":"1d12116030b4a82e","type":"text","text":"#### 5. Top K Frequent Elements (medium)\n\n**Example 1:**\n\n```python\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]\n```\n\n**Complexity**: $O(n \\textrm{log} n)$ time, $O(n)$ space (more optimal: $O(n)$ time, $O(n)$ space)\n```python\nclass Solution:\ndef topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\td = {}\n\tfor n in nums:\n\t\td[n] = d.get(n, 0) + 1\n\t\tarr = [key for key, _ in sorted(list(d.items()), key = lambda x: x[1])]\n\treturn arr[-k:]\n```\n\n**Idea**: for better complexity use bucket sort\n```python\nclass Solution:\n\tdef topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\t\td = {}\n\t\tmax_freq = 0\n\t\tfor n in nums:\n\t\t\td[n] = d.get(n, 0) + 1\n\t\t\tmax_freq = max(max_freq, d[n])\n\t\t\tfreq = [[] for i in range(max_freq + 1)]\n\t\n\t\tfor key in d:\t\n\t\t\tfreq[d[key]].append(key)\n\t\t\n\t\tans = []\n\t\tcur_k = 0\n\t\tj = len(freq) - 1\n\t\twhile j > 0 and cur_k < k:\n\t\t\tif len(freq[j]) > 0:\n\t\t\t\tans += freq[j]\n\t\t\t\tcur_k += len(freq[j])\n\t\t\tj -= 1\n\n\t\treturn ans\n```\n\n**Note**: we should use cur_k += len(freq[j]), not just cur_k += 1 (case of multiple occurrences)","x":-912,"y":-380,"width":873,"height":1020,"color":"4"},
		{"id":"7b0c689b6b51ac40","type":"text","text":"#### 6. Encode and Decode Strings\n\n**Example 1:**\n```python\nInput: [\"neet\",\"code\",\"love\",\"you\"]\n\nOutput:[\"neet\",\"code\",\"love\",\"you\"]\n```\n**Complexity:** $O(\\textrm{sum\\_len})$ \n```python\nclass Solution:\n\n\tdef encode(self, strs: List[str]) -> str:\n\t\treturn(''.join([f'{len(strs[i])}#' + strs[i] for i in range(len(strs))]))\n\tdef decode(self, s: str) -> List[str]:\n\t\ti = 0\n\t\tans = []\n\t\twhile i < len(s):\n\t\t\tj = i\n\t\t\twhile j < len(s) and s[j] != '#':\n\t\t\t\tj += 1\n\t\t\t\tlength = int(s[i : j])\n\t\t\t\tans.append(s[j+1 : j+1+length])\n\t\t\t\ti = j + length + 1\n\t\treturn ans\n```\n\n**Note**: kind of stupid problem","x":-912,"y":640,"width":873,"height":640},
		{"id":"09d6b1737b61f828","type":"text","text":"#### 7. Products of Array Except Self (medium)\n**Idea**: with division - obvious, but should care about 0. Without is more tricky (we should use both prefix and suffix product arrays) \n\n```python\nclass Solution:\n\tdef productExceptSelf(self, nums: List[int]) -> List[int]:\n\t\tpref = [0] * len(nums)\n\t\tpref[0] = nums[0]\n\t\tsuff = [0] * len(nums)\n\t\tsuff[-1] = nums[-1]\n\t\tans = [0] * len(nums)\n\t\n\tfor i in range(1, len(nums)):\n\t\tpref[i] = pref[i - 1] * nums[i]\n\t\tsuff[-i - 1] = suff[-i] * nums[-i - 1]\n\t\tans[0] = suff[1]\n\t\tans[-1] = pref[-2]\n\t\n\tfor i in range(2, len(nums)):\n\t\tans[i - 1] = suff[i] * pref[i - 2]\n\n\treturn ans\n```","x":-912,"y":1280,"width":880,"height":560,"color":"3"},
		{"id":"b7e4d6ad69e2a6ae","type":"text","text":"#### 8. Valid Sudoku (medium)\n\n**Note**L kind of straightforward","x":-912,"y":1840,"width":880,"height":120},
		{"id":"fdd26f29d1879eec","type":"text","text":"#### 9. Longest Consecutive Sequence (medium)\n**Complexity**: $O(n)$ time, $O(n)$ space \n\n**Example 1:**\n\n```python\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4\n```\n\n\n```python\nclass Solution:\n\tdef longestConsecutive(self, nums: List[int]) -> int:\n\t\tif len(nums) == 0:\n\t\treturn 0\n\t\ts_nums = set(nums)\n\t\tmax_len = 1\n\t\tfor num in nums:\n\t\t\tif num - 1 not in s_nums:\n\t\t\t\tlast = num + 1\n\t\t\t\twhile last in s_nums:\n\t\t\t\t\tlast += 1\n\t\t\t\t\tif last - num > max_len:\n\t\t\t\t\t\tmax_len = last - num\n\t\treturn max_len\n```\n\n**Note:**\n- Sorting initial array / getting a hash-smth from it is often a good idea","x":-912,"y":1960,"width":880,"height":690,"color":"3"},
		{"id":"9399d56bf4dee995","type":"text","text":"### 1-DP","x":3855,"y":-1050,"width":250,"height":58},
		{"id":"5cc6128eae340c54","type":"text","text":"#### 1. Climbing stairs (easy)\n```python\nn stairs -> number of ways to reach the top\ndp = [0] * n\ndp[0] = 1\ndp[1] = 2\ndp[i] = dp[i - 1] + dp[i - 2]\ndp = [1, 2, 3, 5, ...]\n```\n","x":3855,"y":-991,"width":640,"height":231},
		{"id":"122717a359d22183","type":"text","text":"#### 2. Min cost climbing stairs (easy)\n```python\ncost -> minimum cost to reach the top\ndp = [0] * len(cost)\ndp[0] = 0\ndp[1] = 0\ndp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n\nreturn(min(min_costs[-1] + cost[-1], min_costs[-2] + cost[-2])) \n```\n","x":3855,"y":-760,"width":640,"height":260},
		{"id":"04f4f95e6c56c34c","type":"text","text":"#### 3. House robber (medium)\n**Note**: \n- don't forget about the start index in cases like \n```python\nfor i in range(2, len(nums)):\n```","x":4495,"y":-992,"width":640,"height":200},
		{"id":"0ddc6ebd59b441b5","type":"text","text":"#### 4. House robber 2 (medium)\n\nSame, but on circle\n\n**Note**:\n- one way to simplify is to pop from list\n- other way to simplify (probably better) is to place -1e9 in the index we want to take; take care about return type and rounding!","x":4495,"y":-792,"width":640,"height":240},
		{"id":"a4f5555b05e2100e","type":"text","text":"#### 5,6. Palindromic substrings (medium)\n**Note**: \n- two ways to solve:\n\t\t1) one loop with using O(n) memory (useful for theoretical approach, but not that much help in practice)\n\t\t2) two loops (seems to be optimal)","x":4495,"y":-552,"width":640,"height":212},
		{"id":"0e5b21ebb6701931","type":"text","text":"### Sliding Window\n","x":2946,"y":-1080,"width":250,"height":60},
		{"id":"e771a6a2509bea84","type":"text","text":"#### 1. Best Time to Buy And Sell Stock (easy)\nNote:\n- don't forget to check if the index within array boundaries in the inner while","x":2946,"y":-1020,"width":637,"height":200},
		{"id":"214534b367fc0833","type":"text","text":"## Theory\n#### Dec to bin:\n\tN -> N % 2 to stack, N //= 2\n#### Negatives:\nsigned int:\n\t0|num, 1|num\n\tnum + bit_inv(num) + 1 = 1|num = -num\n#### Shifting:\n- Logical: shift all bits\n- Arithmetic: shift all bits, replace sign with old\n#### Masks","x":-1632,"y":-2721,"width":653,"height":600},
		{"id":"7d0bee2111ac55dc","type":"text","text":"### 2 pointers","x":-625,"y":-2509,"width":250,"height":60},
		{"id":"4f82fc16cbacf8f6","type":"text","text":"#### Container with most water (medium)\n**Note**: \n- think how to prove the thing\n","x":-625,"y":-2449,"width":465,"height":169},
		{"id":"9d89a0b2d51e986e","type":"text","text":"# Bit manipulation","x":-1632,"y":-2800,"width":353,"height":79},
		{"id":"64695040b3e1d016","type":"text","text":"#### 4. Generate Parantheses (medium)\n**Note**: \n- be careful with self (should provide to functions inside a class)\n- be careful with function's arguments\n- (if balance > 0 ... if max_length...) instead of (... elif max_length)\n\n**Idea**: 1) can open when max_len - balance > cur_len, 2) can close if balance > 0","x":720,"y":3880,"width":817,"height":260,"color":"4"},
		{"id":"9293973923277d1f","type":"text","text":"#### 5. Daily Temperatures (medium)\n```python\nInput: temperatures = [30,38,30,36,35,40,28]\nOutput: [1,4,1,2,1,0,0]\n```\n**Idea**: \"conditional pop\" - if we encounter higher temperature, pop everything before and write the results for every popped case","x":720,"y":4140,"width":817,"height":260,"color":"4"},
		{"id":"2fed24f983fc716f","type":"text","text":"#### 6. Car fleet (medium)\n\n**Note**: don't really need a stack","x":720,"y":4400,"width":817,"height":160},
		{"id":"c2440727e9ab2312","type":"text","text":"### Stack\n\n**Ideas**: \n- saving inputs in order\n- tracking min\n- conditional pop","x":720,"y":1960,"width":817,"height":250,"color":"6"},
		{"id":"33cf1732fbb14794","type":"text","text":"#### 1. Valid Parentheses (easy)\n\n\n**Complexity:** $O(n)$ time, $O(n)$ space\n```python\nclass Solution:\n\tdef isValid(self, s: str) -> bool:\n\t\tstack = []\n\t\top_to_cl = {'(': ')', '{': '}', '[': ']'}\n\t\tfor bracket in s:\n\t\t\tif bracket in op_to_cl:\n\t\t\t\tstack.append(bracket)\n\t\t\telif len(stack) > 0 and bracket == op_to_cl[stack[-1]]:\n\t\t\t\tstack.pop()\n\t\t\telse:\n\t\t\t\treturn False\n\t\tif len(stack) == 0:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n```\n**Note:** \n- easy solution is the best solution, use invariants","x":720,"y":2210,"width":817,"height":560,"color":"4"},
		{"id":"5c3bf5490ccc385e","type":"text","text":"#### 2. Minimum Stack (medium)\n\n**(My) Example:**\n```python\nstack = [1, 2, 0, -1, 4, -2, 6]\nmin_prefix = [1, 1, 0, -1, -1, -2, -2]\n```\n**Complexity:** $O(1)$ time, $O(1)$ space per operation\n\n```python\nclass MinStack:\n\tdef __init__(self):\n\t\tself.stack = []\n\t\tself.min_prefix = []\n\tdef push(self, val: int) -> None:\n\t\tself.stack.append(val)\n\t\tif not self.min_prefix:\n\t\t\tself.min_prefix.append(val)\n\t\telse:\n\t\t\tself.min_prefix.append(min(val, self.min_prefix[-1]))\n\n\tdef pop(self) -> None:\n\t\tself.stack.pop()\n\t\tself.min_prefix.pop()\n\n\tdef top(self) -> int:\n\t\treturn self.stack[-1]\n\n\tdef getMin(self) -> int:\n\t\treturn self.min_prefix[-1]\n```\n\n**Note:**\n- use min_prefix to calculate the minimum of a prefix\n- be careful with 'self' and names\n- use 'if array' to check is empty\n**Idea**: can use less memory (use stack of pairs)","x":720,"y":2765,"width":817,"height":855,"color":"4"},
		{"id":"b55eb6b24b867c7e","type":"text","text":"#### 3. Reverse Polish Notation (medium)\n**Note**: \n- be careful with division in python; int(float(x) / float(y)) is a nice way to avoid bad situations\n\n**Idea**: idea is very basic ([operand_1, operand_2, operator] -> [operator(operand_1, operand_2)]), but should be careful with implementation","x":720,"y":3620,"width":817,"height":260},
		{"id":"fafa89a152533b40","type":"text","text":"#### 1. Valid palindrome (easy)\n**Note**: stupid question, need to remember \n```python\ns.lower().translate(str.maketrans('', '', string.punctuation + ' '))\n```\n\n```python\ns[l].isalnum()\n```","x":-2560,"y":2280,"width":726,"height":219,"color":"4"},
		{"id":"a3e9657fdcc9d226","type":"text","text":"#### 2. Two Sum II Input Array Is Sorted (medium)\n **Idea**: use two pointers - one starts from 0, other starts from len(arr) - 1. sum > target => move right, sum < target => move left","x":-2560,"y":2499,"width":726,"height":130,"color":"4"},
		{"id":"04b6b91b16ca8ed0","type":"text","text":"#### 3. 3Sum (medium)\n\n**Idea**: sort, use the idea with two pointers from previous problem and set to track duplicates","x":-2559,"y":2629,"width":725,"height":136,"color":"4"},
		{"id":"3ce16c2d257e030c","type":"text","text":"#### 4. Container with most water (medium)\n**Idea**: two pointers - one on the 0, other on the len(arr) - 1. Save max area, if left num >= right_num, move right pointer, otherwise move left pointer. To prove the correctness, it's enough to prove that we get the best result for every step with this algorithm.\nEx. \n```python\n[3, 7, 2, 5, 4, 7, 3, 6]\n```\nl = 0, r = 7. for a fixed l, the results will be (r - l) * min(arr[l], arr[r]) = r * min(3, arr[r]) = 3 * r, max when r = 7.  \n","x":-2559,"y":2765,"width":725,"height":314,"color":"4"},
		{"id":"2cd3ad22bf2a91e8","type":"text","text":"### Sliding window","x":-1834,"y":3650,"width":688,"height":100,"color":"6"},
		{"id":"2bfb9a778d4c4d28","type":"text","text":"#### 1. Best time to buy and sell stocks (easy)\n\n**Note**: \n- no need to use 2 while, instead can use 1 with if-else inside","x":-1834,"y":3750,"width":688,"height":217,"color":"4"},
		{"id":"0a2b8f6d5c620720","type":"text","text":"#### 2. Longest Substring Without Repeating Characters (medium)\n\n**Note**: \n- try to avoid moving a pointer bakwards\n- don't forget to update all pointers!","x":-1834,"y":3967,"width":688,"height":195,"color":"3"},
		{"id":"7dffe3c83755595e","type":"text","text":"#### 3. Longest Repeating Character Replacement (medium +)\n","x":-1834,"y":4162,"width":688,"height":203,"color":"2"},
		{"id":"a8f51889967924be","type":"text","text":"#### 4. Permutation in String\n\n**Note**: \n- check if len(target) <= len(main); then it's okay to check if dicts are equal","x":-1834,"y":4365,"width":688,"height":195,"color":"3"},
		{"id":"30b51e19edb371b6","type":"text","text":"### Two pointers\n\n**Ideas**:\n- Pointers can be used in different ways: in the beginning of the algorithm the can be placed in one side, in two sides, in the middle of array","x":-2559,"y":2040,"width":726,"height":240,"color":"6"},
		{"id":"5d260e51fbe44451","type":"text","text":"**To check**:\n1.1 general idea\n1.2. what is asked\n\n2.1. possible update after end of the loop\n2.2 stopping conditions\n\n3.1 initializing variables\n3.2 updating indices in while\n3.3 indexing in general\n3.4. typos\n\n\n\n","x":-1632,"y":-3840,"width":741,"height":476},
		{"id":"7a46f4d090fdd052","type":"text","text":"### Binary search","x":-2876,"y":3650,"width":556,"height":100,"color":"6"},
		{"id":"fbbc299b31b74efe","type":"text","text":"#### 1. Binary search (easy)\n","x":-2876,"y":3750,"width":556,"height":217,"color":"4"},
		{"id":"02e0a005e5e32b35","type":"text","text":"#### 2. 2D binary search (medium)","x":-2876,"y":3967,"width":556,"height":233,"color":"4"},
		{"id":"2d5f90a897775ebd","type":"text","text":"#### Graphs","x":-3177,"y":4960,"width":457,"height":77,"color":"6"},
		{"id":"5dea9feb60bf5ce8","type":"text","text":"#### 1. Number of island (medium)\n\nNote: \n- don't forget about assigning \"-1\" to initial vertex","x":-3177,"y":5037,"width":457,"height":203,"color":"3"},
		{"id":"0031a06d3a1688f4","type":"text","text":"#### 2. Max area of island (medium)","x":-3177,"y":5200,"width":457,"height":160,"color":"4"},
		{"id":"0556f3d8a674efc4","type":"text","text":"#### 4. Islands and Treasure\nNote:\n- BFS","x":-3177,"y":5440,"width":457,"height":160,"color":"4"},
		{"id":"a7bcf114ba10a604","type":"text","text":"#### 3. Clone graph","x":-3177,"y":5360,"width":457,"height":80},
		{"id":"2e88fbbd305775cf","type":"text","text":"#### 1. Maximum average subarray len k (easy)\nConstant window","x":-1834,"y":4640,"width":688,"height":140},
		{"id":"93f3632b8246065e","type":"text","text":"#### 2. Longest subarray with  sum <= k (non-negative numbers)\ncur_sum <= k => curr_sum += arr[r], r++, update max_sum\ncur_sum > k => curr_sum += arr[r] - arr[l], r++, l ++","x":-1834,"y":4780,"width":688,"height":140},
		{"id":"5d77f501195ad2c1","type":"text","text":"#### 3. Maximum subarray sum\n\n(variant with l = r = 0, max_sum = float('-inf'), cur_sum = 0)\ncur_sum += arr[r], r++, update max_sum\nwhile cur_sum < 0:\n\tcur_sum -= arr[l]\n\t l += 1","x":-1834,"y":4920,"width":688,"height":200},
		{"id":"41073e1ca5cb6f0c","type":"text","text":"#### 4.1. Array to string with intervals\n\n#### 4.2. Max monotonic subarray","x":-1834,"y":5120,"width":688,"height":120},
		{"id":"fab333bdd8515a43","type":"text","text":"#### 5. Max consecutive ones III","x":-1834,"y":5240,"width":688,"height":160}
	],
	"edges":[
		{"id":"9e31fd0769d9e264","fromNode":"69fcdb7a30a0ea65","fromSide":"bottom","toNode":"6828173c4be6bcc9","toSide":"top"},
		{"id":"6546b7f4c583e9a6","fromNode":"6828173c4be6bcc9","fromSide":"bottom","toNode":"08f7dabd09700350","toSide":"top"},
		{"id":"6c09a81675bb63ba","fromNode":"4c19af82c647267a","fromSide":"bottom","toNode":"1d12116030b4a82e","toSide":"top"},
		{"id":"df5aed931ed62937","fromNode":"1d12116030b4a82e","fromSide":"bottom","toNode":"7b0c689b6b51ac40","toSide":"top"},
		{"id":"e6608f741a04a8a8","fromNode":"5c3bf5490ccc385e","fromSide":"bottom","toNode":"b55eb6b24b867c7e","toSide":"top"},
		{"id":"d231fd9cfa59c65d","fromNode":"b55eb6b24b867c7e","fromSide":"bottom","toNode":"64695040b3e1d016","toSide":"top"},
		{"id":"7c177662b2a55097","fromNode":"153cb32d025e9f16","fromSide":"left","toNode":"30b51e19edb371b6","toSide":"top"},
		{"id":"c0aa89923be2fba5","fromNode":"153cb32d025e9f16","fromSide":"right","toNode":"c2440727e9ab2312","toSide":"top"},
		{"id":"89ddb6393446b7ff","fromNode":"3ce16c2d257e030c","fromSide":"bottom","toNode":"2cd3ad22bf2a91e8","toSide":"top"},
		{"id":"2fdea27e970aab48","fromNode":"3ce16c2d257e030c","fromSide":"bottom","toNode":"7a46f4d090fdd052","toSide":"top"},
		{"id":"6b6ba091018d83b1","fromNode":"a8f51889967924be","fromSide":"bottom","toNode":"2e88fbbd305775cf","toSide":"top"}
	]
}